# AM335x解决网络压力测试的问题_20240419

## 2024-04-19：



> [!caution]
>
> <font face="微软雅黑" color=yellow>**问题1：**</font><font face="微软雅黑" color=yellow>**许继最近在现场`CCE-D2200`的网络压力测试实验中，反馈说网络压力实验无法通过。**</font>

廖工提起，之前我们在`SWM-4410`的板卡上，曾经直接修改过`AM335x`的`MAC`驱动代码，将以太网进来的包，将广播包（且不是`ARP`包）直接丢弃，而不进入到下一级。

`SWM-4410`板卡的内核是基于`V3.2`版本的，修改的文件为：[cpsw.c](file:///home/jason/ubuntu13.04/arm/am335x/swm4410_190525/kernel/drivers/net/ethernet/ti/cpsw.c)

在函数`void cpsw_rx_handler(void *token, int len, int status)`中，修改了以下代码：

```c
void cpsw_rx_handler(void *token, int len, int status)
{
	struct sk_buff		*skb = token;
	struct net_device	*ndev = skb->dev;
	struct cpsw_priv	*priv = netdev_priv(ndev);
	int			ret = 0;
	struct 			ethhdr *eth;

	cpsw_dual_emac_source_port_detect(status, priv, ndev, skb);

	if (unlikely(!netif_running(ndev)) ||
			unlikely(!netif_carrier_ok(ndev))) {
		dev_kfree_skb_any(skb);
		return;
	}

	if (likely(status >= 0)) {

		//Jason.Wang: 2020-09-17:在此处实现MAC地址过滤
//		if ((skb->pkt_type == PACKET_BROADCAST) || (skb->pkt_type == PACKET_MULTICAST)
//			|| (skb->pkt_type == PACKET_OTHERHOST)) {
//			printk(KERN_INFO "skb->pkt_type: %d\n", skb->pkt_type);
//		}

		//printk(KERN_INFO "skb->pkt_type: %d\n", skb->pkt_type);

		skb_put(skb, len);
		cpts_rx_timestamp(priv->cpts, skb);
		skb->protocol = eth_type_trans(skb, ndev);

		//Jason.Wang: 2020-09-17:在此处实现MAC地址和报文类型过滤
		//Jason.Wang: 2020-09-17, 为了抵御网络风暴测试
		eth = eth_hdr(skb);
		
		//如果是广播报文且类型不是ARP协议，则丢弃
		if ((skb->pkt_type == PACKET_BROADCAST) && (ntohs(skb->protocol) != ETH_P_ARP)) {
			kfree_skb(skb);
		}

		//如果是组播报文且类型不是GOOSE，则丢弃
		else if ((skb->pkt_type == PACKET_MULTICAST) 
			&& (((eth->h_dest[0] ^ 0x01) | (eth->h_dest[1] ^ 0x0c) | (eth->h_dest[2] ^ 0xcd)) != 0)) {
			     kfree_skb(skb);
		} else {
			netif_receive_skb(skb);
		}

		priv->stats.rx_bytes += len;
		priv->stats.rx_packets++;
		skb = NULL;
	}


	if (unlikely(!netif_running(ndev))) {
		if (skb)
			dev_kfree_skb_any(skb);
		return;
	}

	if (likely(!skb)) {
		skb = netdev_alloc_skb_ip_align(ndev, priv->rx_packet_max);
		if (WARN_ON(!skb))
			return;

		ret = cpdma_chan_submit(priv->rxch, skb, skb->data,
				skb_tailroom(skb), 0, GFP_KERNEL);
	}

	WARN_ON(ret < 0);

}

```


> [!tip]
>
> <font face="微软雅黑" color=yellow>**注意代码中带有`Jason.Wang`注释的地方，均为修改过后的代码。**</font>

---

现在在`CCE-2200`（内部采用的是`SWM61850_MINI+_V4.0`板卡）上修改，内核`4.19`：
```c
static void cpsw_rx_handler(void *token, int len, int status)
{
	struct cpdma_chan	*ch;
	struct sk_buff		*skb = token;
	struct sk_buff		*new_skb;
	struct net_device	*ndev = skb->dev;
	int			ret = 0, port;
	struct cpsw_common	*cpsw = ndev_to_cpsw(ndev);
	struct cpsw_priv	*priv;
	struct ethhdr 		*eth;

	if (cpsw->data.dual_emac) {
		port = CPDMA_RX_SOURCE_PORT(status);
		if (port) {
			ndev = cpsw->slaves[--port].ndev;
			skb->dev = ndev;
		}
	}

	if (unlikely(status < 0) || unlikely(!netif_running(ndev))) {
		/* In dual emac mode check for all interfaces */
		if (cpsw->data.dual_emac && cpsw->usage_count &&
		    (status >= 0)) {
			/* The packet received is for the interface which
			 * is already down and the other interface is up
			 * and running, instead of freeing which results
			 * in reducing of the number of rx descriptor in
			 * DMA engine, requeue skb back to cpdma.
			 */
			new_skb = skb;
			goto requeue;
		}

		/* the interface is going down, skbs are purged */
		dev_kfree_skb_any(skb);
		return;
	}

	new_skb = netdev_alloc_skb_ip_align(ndev, cpsw->rx_packet_max);
	if (new_skb) {
		skb_copy_queue_mapping(new_skb, skb);
		skb_put(skb, len);
		if (status & CPDMA_RX_VLAN_ENCAP)
			cpsw_rx_vlan_encap(skb);

		priv = netdev_priv(ndev);
		if (priv->rx_ts_enabled)
			cpts_rx_timestamp(cpsw->cpts, skb);

		skb->protocol = eth_type_trans(skb, ndev);

		//Jason.Wang: 2024-04-19:在此处实现MAC地址和报文类型过滤
		//Jason.Wang: 2024-04-19, 为了抵御网络风暴测试
		eth = eth_hdr(skb);
				
		//如果是广播报文且类型不是ARP协议，则丢弃
		if ((skb->pkt_type == PACKET_BROADCAST) && (ntohs(skb->protocol) != ETH_P_ARP)) {
			kfree_skb(skb);
		}

		//Jason.Wang: 2024-04-19:如果是组播报文且类型不是GOOSE，则丢弃
//		else if ((skb->pkt_type == PACKET_MULTICAST)
//			&& (((eth->h_dest[0] ^ 0x01) | (eth->h_dest[1] ^ 0x0c) | (eth->h_dest[2] ^ 0xcd)) != 0)) {
//			     kfree_skb(skb);
//		}

		//Jason.Wang: 2024-04-19:否则接收skb包
		else {
			netif_receive_skb(skb);
		}


		//netif_receive_skb(skb);
		ndev->stats.rx_bytes += len;
		ndev->stats.rx_packets++;
		kmemleak_not_leak(new_skb);
	} else {
		skb->protocol = eth_type_trans(skb, ndev);
		pr_err("0x%x\n", skb->protocol);
		ndev->stats.rx_dropped++;
		new_skb = skb;
	}

requeue:
	if (netif_dormant(ndev)) {
		dev_kfree_skb_any(new_skb);
		return;
	}

	ch = cpsw->rxv[skb_get_queue_mapping(new_skb)].ch;
	ret = cpdma_chan_submit(ch, new_skb, new_skb->data,
				skb_tailroom(new_skb), 0);
	if (WARN_ON(ret < 0))
		dev_kfree_skb_any(new_skb);
}

```

> [!tip]
>
> <font face="微软雅黑" color=yellow>**注意代码中带有`Jason.Wang`注释的地方，均为修改过后的代码。**</font>

---

> [!IMPORTANT]
> <font face="微软雅黑" color=cyan>**结论：**</font><font face="微软雅黑" color=cyan>**在解决网络压力注入问题时，均可以按照这个思路来做。修改网络驱动代码，在接收一级直接过滤网络包（一般为广播包，不含`arp`包）。**</font>



> [!NOTE]  
> Highlights information that users should take into account, even when skimming.

> [!TIP]
> Optional information to help a user be more successful.

> [!IMPORTANT]  
> Crucial information necessary for users to succeed.

> [!WARNING]  
> Critical content demanding immediate user attention due to potential risks.

> [!CAUTION]
> Negative potential consequences of an action.
