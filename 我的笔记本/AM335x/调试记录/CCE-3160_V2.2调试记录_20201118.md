# CCE-3160_V2.2调试记录_20201118

### 1、烧写CPLD后，上电系统不启动的解决：

CCE-3160_V2.2版本硬件设计采用国产紫光的PGC2KG-6LPG100芯片，程序逻辑编译完成后烧写进CPLD后，上电或者复位系统不启动。
        仔细研究发现在烧写时，需要手动设置软件界面“Generate Bitsream”（右键点击，选择Project Setting），打开设置界面，
        在“Feature Control”选项卡中，去掉“Disable RST_N Pin In Configuration”勾选，再重新编译，烧写CPLD，系统才能正常启动。
        猜测应该我硬件设计时，将系统的sys_reset_n输出信号连接至CPLD的复用管脚RST_N上导致，后续设计可以将sys_reset_n信号移植其它管脚，再做测试。

### 2、第二路以太网PHY芯片上电后LED0指示灯常亮，导致PHY地址不对的解决方案：

设计上采用RTL8201F芯片，两路PHY地址分别为0x2和0x3，原设计方案没有问题。后因为芯片短缺，更换为国产景略半导体的JL1111，
        出现第二路上电后LED0指示灯常亮的现象，导致PHY地址0x3不正确，进入Linux系统后无法通讯。经过研究发现此时手动按下复位按钮，
        LED0指示灯熄灭，通讯正常。经过咨询厂家得知，JL1111的上电复位与RTL8201F并不一致，需要拉长一段时间。修改CPLD代码，增加复位时间：
        
        //--------------------------------------------------------------------------------------------------------------------------
        //增加复位逻辑，为了解决景略JL1111的上电复位问题
        //将系统复位输出延长10ms输出
        //--------------------------------------------------------------------------------------------------------------------------
        `define RESET_SUM	100000
        `define RESET_WIDTH	17
        reg [`RESET_WIDTH - 1:0] rst_counter;
        reg rst_out1, rst_out2;

        always @(posedge wdg_clk or negedge sys_rst_n)
        begin
        	if(!sys_rst_n)
        		rst_counter <= `RESET_WIDTH'b0;
        	else if(rst_counter < `RESET_SUM)
        		rst_counter <= rst_counter + `RESET_WIDTH'b1;
        	else
        		rst_counter <= rst_counter;
        end

        always @(posedge wdg_clk or negedge sys_rst_n)
        begin
        	if(!sys_rst_n)
        		rst_out1 <= 1'b0;
        	else if(rst_counter < `RESET_SUM)
        		rst_out1 <= 1'b1;
        	else
        		rst_out1 <= 1'b0;
        end

        // assign rst_out_p = !sys_reset_n;
        // assign rst_out_n =  sys_reset_n;
        assign rst_out_p = rst_out1;
        assign rst_out_n = ~rst_out1;

按照以上代码修改后的复位逻辑，芯片可以正常工作了。上电后可以看到LED0指示灯闪一下，然后熄灭。

### 3、KS8851以太网控制驱动代码的修改：

ks8851配置好设备树之后，还需要修改drivers/memory/omap_gpmc.c文件，添加节点，此时可以找到并加载驱动，但是ping不通，需要修改驱动代码：
        
        static int ks_net_open(struct net_device *netdev)
        {
                	struct ks_net *ks = netdev_priv(netdev);
                	int err;
                	unsigned long irq_flags;

                #define	KS_INT_FLAGS	IRQF_TRIGGER_LOW
                	/* lock the card, even if we may not actually do anything
                	 * else at the moment.
                	 */

                	irq_flags = (IRQF_ONESHOT | IRQF_TRIGGER_LOW);
                	//irq_flags = (IRQF_SHARED | IRQF_TRIGGER_FALLING);
                	netif_dbg(ks, ifup, ks->netdev, "%s - entry\n", __func__);

                	/* reset the HW */
                	//err = request_irq(netdev->irq, ks_thread_irq, KS_INT_FLAGS, DRV_NAME, netdev);
                	err = request_threaded_irq(netdev->irq, NULL, ks_thread_irq, irq_flags, DRV_NAME, netdev);

                	if (err) {
                		pr_err("Failed to request IRQ: %d: %d\n", netdev->irq, err);
                		return err;
                	}

                	/* wake up powermode to normal mode */
                	ks_set_powermode(ks, PMECR_PM_NORMAL);
                	mdelay(1);	/* wait for normal mode to take effect */

                	ks_wrreg16(ks, KS_ISR, 0xffff);
                	ks_enable_int(ks);
                	ks_enable_qmu(ks);
                	netif_start_queue(ks->netdev);

                	netif_dbg(ks, ifup, ks->netdev, "network device up\n");

                	return 0;
        }

同时，中断处理程序中还需要添加加锁机制：
        
        static irqreturn_t ks_thread_irq(int irq, void *pw)
        {
                	struct net_device *netdev = pw;
                	struct ks_net *ks = netdev_priv(netdev);
                	unsigned long flags;
                	u16 status;

                	spin_lock_irqsave(&ks->statelock, flags);
                	/*this should be the first in IRQ handler */
                	ks_save_cmd_reg(ks);

                	status = ks_rdreg16(ks, KS_ISR);
                	if (unlikely(!status)) {
                		ks_restore_cmd_reg(ks);
                		spin_unlock_irqrestore(&ks->statelock, flags);
                		return IRQ_NONE;
                	}

                	ks_wrreg16(ks, KS_ISR, status);

                	if (likely(status & IRQ_RXI))
                		ks_rcv(ks, netdev);

                	if (unlikely(status & IRQ_LCI))
                		ks_update_link_status(netdev, ks);

                	if (unlikely(status & IRQ_TXI))
                		netif_wake_queue(netdev);

                	if (unlikely(status & IRQ_LDI)) {

                		u16 pmecr = ks_rdreg16(ks, KS_PMECR);
                		pmecr &= ~PMECR_WKEVT_MASK;
                		ks_wrreg16(ks, KS_PMECR, pmecr | PMECR_WKEVT_LINK);
                	}

                	if (unlikely(status & IRQ_RXOI))
                		ks->netdev->stats.rx_over_errors++;
                	/* this should be the last in IRQ handler*/
                	ks_restore_cmd_reg(ks);
                	spin_unlock_irqrestore(&ks->statelock, flags);
                	return IRQ_HANDLED;
        }

除此以外，还修改了插拔网线时的link提示信息：

        static void ks_update_link_status(struct net_device *netdev, struct ks_net *ks)
        {
                	/* check the status of the link */
                	u32 link_up_status;
                	struct mii_if_info *mii = &ks->mii;
                	int advertise, lpa, media, duplex;
                	int lpa2 = 0;
                	
                	if (ks_rdreg16(ks, KS_P1SR) & P1SR_LINK_GOOD) {
                		netif_carrier_on(netdev);
                		link_up_status = true;
                	} else {
                		netif_carrier_off(netdev);
                		link_up_status = false;
                	}
                	//netif_dbg(ks, link, ks->netdev,
                		//"%s: %s\n", __func__, link_up_status ? "UP" : "DOWN");

                	//netdev_info(ks->netdev, "link is %s\n", link_up_status ? "UP" : "DOWN");

                	if (!link_up_status) {
                		netdev_info(ks->netdev, "link is DOWN\n");
                	} else {
                		advertise = mii->mdio_read(mii->dev, mii->phy_id, MII_ADVERTISE);
                		lpa = mii->mdio_read(mii->dev, mii->phy_id, MII_LPA);
                		if (mii->supports_gmii)
                			lpa2 = mii->mdio_read(mii->dev, mii->phy_id, MII_STAT1000);

                		/* figure out media and duplex from advertise and LPA values */
                		media = mii_nway_result(lpa & advertise);
                		duplex = (media & ADVERTISE_FULL) ? 1 : 0;
                		if (lpa2 & LPA_1000FULL)
                			duplex = 1;

                		netdev_info(ks->netdev, "link up, %uMbps, %s-duplex, lpa 0x%04X\n",
                			    lpa2 & (LPA_1000FULL | LPA_1000HALF) ? 1000 :
                			    media & (ADVERTISE_100FULL | ADVERTISE_100HALF) ?
                			    100 : 10,
                			    duplex ? "full" : "half",
                			    lpa);
                	}
        }


### 3、关于扩展串口中断总是不行的解决方案：

是DTB的问题，中断不能放在下一级描述，正确的描述如下：
        
        extuartcs@2,0 {
		compatible = "ns16550a";
             	reg = <2 0 0x8>;  /* CS2, offset 0, IO size 0x8 */
                bank-width = <1>;
                reg-shift = <0>;
                reg-io-width = <1>;
                interrupt-parent = <&gpio3>;
                interrupts = <14 IRQ_TYPE_LEVEL_HIGH>;  /* gpio102 */
                clock-frequency = <14745600>;
                current-speed = <115200>;
                 gpmc,mux-add-data = <0>;
                  gpmc,device-width = <1>;
                  gpmc,wait-pin = <1>;
                  gpmc,cycle2cycle-samecsen = <1>;
                  gpmc,cycle2cycle-diffcsen = <1>;
                  gpmc,cs-on-ns = <5>;
                 gpmc,cs-rd-off-ns = <155>;
                  gpmc,cs-wr-off-ns = <155>;
                  gpmc,adv-on-ns = <15>;
                  gpmc,adv-rd-off-ns = <40>;
                 gpmc,adv-wr-off-ns = <40>;
                  gpmc,oe-on-ns = <45>;
                  gpmc,oe-off-ns = <145>;
                  gpmc,we-on-ns = <45>;
                  gpmc,we-off-ns = <145>;
                  gpmc,rd-cycle-ns = <155>;
                  gpmc,wr-cycle-ns = <155>;
                  gpmc,access-ns = <145>;
                  gpmc,page-burst-access-ns = <20>;
                  gpmc,bus-turnaround-ns = <20>;
                  gpmc,cycle2cycle-delay-ns = <20>;
                  gpmc,wait-monitoring-ns = <0>;
                  gpmc,clk-activation-ns = <0>;
                  gpmc,wr-data-mux-bus-ns = <45>;
                  gpmc,wr-access-ns = <145>;
	};

	extuartcs@2,1 {
		compatible = "ns16550a";
             	reg = <2 0x8 0x8>;  /* CS2, offset 0, IO size 0x8 */
                bank-width = <1>;
                reg-shift = <0>;
                reg-io-width = <1>;
                interrupt-parent = <&gpio3>;
                interrupts = <14 IRQ_TYPE_LEVEL_HIGH>;  /* gpio102 */
                clock-frequency = <14745600>;
                current-speed = <115200>;
                 
	};

	extuartcs@2,2 {
		compatible = "ns16550a";
             	reg = <2 0x10 0x8>;  /* CS2, offset 0, IO size 0x8 */
                bank-width = <1>;
                reg-shift = <0>;
                reg-io-width = <1>;
                interrupt-parent = <&gpio3>;
                interrupts = <14 IRQ_TYPE_LEVEL_HIGH>;  /* gpio102 */
                clock-frequency = <14745600>;
                current-speed = <115200>;
                 
	};

	extuartcs@2,3 {
		compatible = "ns16550a";
             	reg = <2 0x18 0x8>;  /* CS2, offset 0, IO size 0x8 */
                bank-width = <1>;
                reg-shift = <0>;
                reg-io-width = <1>;
                interrupt-parent = <&gpio3>;
                interrupts = <14 IRQ_TYPE_LEVEL_HIGH>;  /* gpio102 */
                clock-frequency = <14745600>;
                current-speed = <115200>;
                 
	};

### 4、CPLD的设备树描述和中断描述也需要像扩展串口一样，放到上一层去描述：

        misccpld@3,0 {
		// status = "okay";
		// pinctrl-names = "default";
		// pinctrl-0 = <&cpld_irq_pins_default>;

		compatible = "sanway,cpld";
		reg = <3 0 0x1000>;

		//reg = <3 0 0x04000000>;
		bank-width = <1>;
		gpmc,device-width = <1>;
		//gpmc,wait-pin = <0>;
		//gpmc,wait-on-read = "true";
		//gpmc,wait-on-write = "true";

		interrupt-parent = <&gpio3>;
		interrupts = <17 IRQ_TYPE_EDGE_RISING>,
			     <18 IRQ_TYPE_EDGE_RISING>,
			     <19 IRQ_TYPE_EDGE_RISING>;
		
		/*config6*/
		gpmc,wr-access-ns = <10>;
		gpmc,wr-data-mux-bus-ns = <20>;
		gpmc,cycle2cycle-delay-ns = <100>;
		gpmc,bus-turnaround-ns = <0>;
		//gpmc,cycle2cycle-diffcsen = "true";
		//gpmc,cycle2cycle-samecsen = "true";
		
		gpmc,sync-clk-ps = <0>;
		gpmc,cs-on-ns = <0>;
		gpmc,adv-on-ns = <10>;
		
		/*read*/
		gpmc,adv-rd-off-ns = <20>;
		gpmc,oe-on-ns = <30>;
		gpmc,access-ns = <100>;
		gpmc,oe-off-ns = <120>;
		gpmc,cs-rd-off-ns = <180>;
		gpmc,rd-cycle-ns = <200>;
		
		 /*write*/
		gpmc,adv-wr-off-ns = <10>;
		gpmc,we-on-ns = <30>;
		gpmc,we-off-ns = <130>;
		gpmc,cs-wr-off-ns = <160>;
		gpmc,wr-cycle-ns = <280>;
		
		// #address-cells = <1>;
		// #size-cells = <1>;
		// ranges = <0x10000000 3 0 0x04000000>;

		// cpld@0{
		// 	compatible = "sanway,cpld";
		// 	reg = <0x10000000 0x1000>;
		// };
	};

### 5、调试时可以设置nfs方式启动，修改了文件系统以后，再一次性打包成ubi.img：
可以在u-boot下设置以下环境变量：

        set nandnfsargs "setenv bootargs console=ttyO0,115200n8 root=/dev/nfs nfsroot=192.168.1.103:/media/ubuntu13.04/home/wanglei/arm/am335x/cce-3160/v2.2_20201020/linux-4.19-rt/rootfs/rootfs,nolock rw ip=192.168.1.233:192.168.1.103:192.168.1.1:255.255.255.0::eth3:off"
        
        set nandnfsboot "echo Booting from nand ...; run nandnfsargs; nand read ${fdtaddr} u-boot-spl-os; nand read ${loadaddr} kernel; bootz ${loadaddr} - ${fdtaddr}"
        
        saveenv
        
        run nandnfsboot