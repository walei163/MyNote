# 1. 宁波启新ITR-1000T调试记录_20210302

## 1.1. 传感器测试：

        板上的SHT3x采用硬件I2C1，但是对应到Linux系统下为I2C0；
        外接的SHT3x采用硬件I2C2，但是对应到Linux系统下为I2C1；
        Linux系统下的I2C2实际对应的硬件为I2C4，也就是连接CPU的电源管理芯片。
        测试中发现，需要将sht3x驱动编译为模块方式加载，才能正确操作传感器设备。
        注意在加载sht3x.ko之前，需要先insmod crc8.ko模块。

## 1.2. 液晶屏显示测试：

硬件测试发现连接主板和面板的40pin插座管脚定义上下颠倒了，后期需要改面板。同时面板上的液晶屏的柔性排缆连接到面板背部的插座位置偏移比较多，无法直接对齐，后期改板需要修正过来。

QT界面在和按键配合时，需要做以下改动：

        1、需要重新编译QT库，注释掉初始化TTY虚拟串口，否则将会导致QT程序运行起来后，会占用当前的tty终端，具体说明如下：

                最近发现一个问题，当我在嵌入式设备中使用环境变量QWS_KEYBOARD的时候，运行Qt程序，程序会被挂起。串口终端那边无法再输入任何东西。上
                网查找原因，发现也有其他的人碰到过这个问题，他们大多数的解决办法就是使用QWS_USB_KEYBOARD，但是由于我使用的是i2c的键盘设备，而不是usb的，
                所以这种方法对我没什么用。最后看到一篇老外的帖子，他提到需要修改Qt的源代码。

        下面是修改部分：

        修改.../src/gui/embedded/qkbdlinuxinput_qws.cpp

        #if 0
                if (m_tty_fd >= 0) {
                    // save tty config for restore.
                    tcgetattr(m_tty_fd, &m_tty_attr);

                    struct ::termios termdata;
                    tcgetattr(m_tty_fd, &termdata);

                    // record the original mode so we can restore it again in the destructor.
                    ::ioctl(m_tty_fd, KDGKBMODE, &m_orig_kbmode);

                    // setting this translation mode is even needed in INPUT mode to prevent
                    // the shell from also interpreting codes, if the process has a tty
                    // attached: e.g. Ctrl+C wouldn't copy, but kill the application.
                    ::ioctl(m_tty_fd, KDSKBMODE, K_MEDIUMRAW);

                    // set the tty layer to pass-through
                    termdata.c_iflag = (IGNPAR | IGNBRK) & (~PARMRK) & (~ISTRIP);
                    termdata.c_oflag = 0;
                    termdata.c_cflag = CREAD | CS8;
                    termdata.c_lflag = 0;
                    termdata.c_cc[VTIME]=0;
                    termdata.c_cc[VMIN]=1;
                    cfsetispeed(&termdata, 9600);
                    cfsetospeed(&termdata, 9600);
                    tcsetattr(m_tty_fd, TCSANOW, &termdata);
                }
        #endif


        将这段代码注释掉，重新编译替换原来的libQtGui.so.4文件即可

        完成之后export QWS_KEYBOARD="LinuxInput:/dev/input/event1" 就可以正确使用键盘了


        2、需要设置/etc/profile，添加环境变量：
        QWS_KEYBOARD="LinuxInput:/dev/input/event1"

        3、QT程序中无法捕捉KEY_UP和KEY_DOWN键值，需要将CPLD驱动中的上报键值更换为KEY_PAGEDOWN和KEY_PAGEUP键值，就可以实现上下键了。

测试温湿度传感器：

1、发现在板的温湿度传感器和第一路的温湿度检测值差异很大，估计是这一路温湿度在板上焊接的地方靠近隔离DCDC芯片，发热较大。
2、后期需要改板的地方：

        1）、在板的温湿度传感器需要移到一个板上不太发热的地方，目前找到的地方是可以放在锂电池的右边，靠近板边的地方。
        2）、在板的DTU模块需要从板子的背面移到板子的正面，否则后期使用时不要安装DTU模块。
        3）、波动开关需要上下颠倒一下，即改为向上为闭合，向下为断开，这样符合使用习惯。
        4）、以太网RJ45插座需要改为缺口向上的插座，现在所使用的缺口向下的插座，一旦网线插入，就不好拔出了。
3、模拟量采样实现方式：

        由M4负责采样模拟量，然后通过虚拟串口向A7发送原始采样数据，A7端根据采样的原始数据再计算真实值。双方约定串行通讯协议为：
        0x55 0xaa 第一路220VPTC电流值（2字节，小端模式） 第二路220VPTC电流值 24VFILTER电流值 压力值 16位和校验
        一共12个字节。
        因为这些模拟量均通过继电器来开启供电，当继电器未打开或者外部悬空未连接设备时，其初始值为（注意以下均为16位采样）：

        1、第一路220V PTC：0xa5b0(42416)
        2、第二路220V PTC：0xa6b0(42672)
        3、压力传感器：0x6500（25856）
        4、24V FILTER：0x400（1024）
        计算时需要用：(采样的数据值 - 初始值) x 3.3 / 65535

        当外部加载了设备时，读取值为：
        
        1、压力传感器：
        在连接了10V的压力传感器后，读取的数值约为：26045，测算出的真实值为：(26045 - 25856) x 3.3 / 32768，因为采样电路被线性光耦从0～10V缩放到了0～2V，
        因此最后还需要添加修正系数，即：
                采样计算值 / 2 x 10
                
        2、24V FILTER测量值：
        FILTER滤网加热片经过测量电阻值为200欧姆，连接后读取的数值应为：24V / 200 = 0.12A
        因为硬件电路经过AD8217转换为电压读取，AD8217的放大倍数为20，并且串联的是1欧姆的电阻，因此最终电流值公式为：
        电流值（浮点数） = (采样值 - 初始值) x 3.3 / 65535 / 20