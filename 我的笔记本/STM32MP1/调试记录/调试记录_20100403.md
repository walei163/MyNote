1. 经过测试，STM32MP157C-EV1的DTB文件可用于SWA1530，但由于硬件上TF卡的设计不同，因此需要修改，否则无法启动。TFA模式修改DTB文件stm32mp157c-ed1.dts：

```
&sdmmc1 {
	pinctrl-names = "default";
	pinctrl-0 = <&sdmmc1_b4_pins_a>;
	broken-cd;
	st,neg-edge;
	bus-width = <4>;
	vmmc-supply = <&v3v3>;
	status = "okay";
};

```
U-boot下也需要修改DTB文件stm32mp157c-ed1.dts，内容同上。除此以外，还需要修改pinctrl管脚配置。这样就可以引导了。无论是TFA模式还是BASIC模式都可以正确引导系统。
###### TFA模式：
编译arm-trusted-firmware-2.0/下代码即可：
```
#!/bin/sh
unset LDFLAGS
unset CFLAGS
make ARM_ARCH_MAJOR=7 ARCH=aarch32 PLAT=stm32mp1 AARCH32_SP=sp_min DTB_FILE_NAME=stm32mp157c-ev1.dtb 
```
采用TFA模式时，U-boot下需要按照以下方式编译：
```
make stm32mp15_trusted_defconfig
make DEVICE_TREE=stm32mp157c-ev1 all
```
编译完成后，生成的文件分别为：
`tf-a-stm32mp157c-ev1.stm32，u-boot.stm32`

###### BASIC模式：
该模式不需要编译arm-trusted-firmware-2.0/下代码，只需要编译U-boot：
```
make stm32mp15_basic_defconfig
make DEVICE_TREE=stm32mp157c-ev1 all
```
编译完成后，生成的文件分别为：
`u-boot-spl.stm32， u-boot.img`

2. 系统启动后，会自动进入Linux文件系统，使用模式类似于ubuntu模式，可以采用以下命令来安装一些软件：
```
apt-get update
apt-get install
apt-cache search .        //该命令可以查看软件库中都有哪些软件包
```
例如：安装nfs客户端，可以直接挂在电脑上的nfs共享目录：
```
apt-get install nfs-utils*
```
安装完成后，可以mount服务器：
```
mount 192.168.1.145:/media/ubuntu13.04/home/wanglei/arm/STM32MPU_workspace/swa1530_200318/images /mnt -o vers=3
```

如果出现错误提示：
        
        svc: failed to register lockdv1 RPC service (errno 111)

则可以加上参数：
        
        -o nolock

实测也可以按照以下方式挂载本机系统：

        mount.nfs4 192.168.1.145:/media/ubuntu13.04/home/wanglei/arm/STM32MPU_workspace/swa1530_200318/images /mnt

3. eMMC安装方式：

    1). 将TFA固件烧入到mmcblk1boot0和mmcblk1boot1中：

```
echo 0 > /sys/block/mmcblk1boot0/force_ro 
echo 0 > /sys/block/mmcblk1boot1/force_ro 
./sh_dd_image tf-a-stm32mp157c-ev1.stm32 /dev/mmcblk1boot0
./sh_dd_image tf-a-stm32mp157c-ev1.stm32 /dev/mmcblk1boot1
```
   2). 启动进入U-boot shell下，激活mmcblk1boot1分区，使其作为引导分区：

```
    mmc dev 1        //表示将mmc设备切换到第1个设备，也就是emmc
    mmc dev 1 0      //表示切换到第1个设备的boot0分区
    mmc dev 1 1      //表示切换到第1个设备的boot1分区
    mmc dev 1 2      //表示切换到第1个设备的UDA分区    
    
    mmc partconf 1 1 1 1        //表示设置emmc的boot0为引导分区
    mmc partconf 1 1 2 1        //表示设置emmc的boot1为引导分区    
    mmc partconf 1 1 7 1        //表示设置emmc的用户分区为引导分区    

    mmc partconf 1         //表示查看emmc的PARTITION_CONFIG寄存器的配置字信息

    mmc dev 1
    mmc part                //表示查看emmc上的UDA的分区信息
```
注意！目前发现个别emmc芯片除了需要boot0引导分区以外，还需要设置BOOT_BUS_CONFIG寄存器的内容！emmc有3个寄存器是非常重要的：

        Boot configuration bytes [PARTITION_CONFIG: 0x48]
        Boot config protection： [BOOT_CONFIG_PROT: 0x00]
        Boot bus Conditions [BOOT_BUS_CONDITIONS: 0x00]
STM32MP1的CPU需要的emmc的寄存器的值如上面所示。一般如果需要设置，则可以在U-boot下：

        mmc partconf 1 1 1 1        //激活boot0为引导分区
        mmc bootbus 1 0 0 0        //设置BOOT_BUS_CONDITIONS寄存器的值为0

也可以在Linux下操作：

```
linux下关闭EMMC启动：
mmc bootpart enable 0 0 /dev/mmcblk1
Linux下启用EMMC启动
mmc bootpart enable 1 1 /dev/mmcblk1
```

        Linux下设置BOOT BUS CONDITIONS寄存器的命令（注意要用官方SD卡启动，文件系统中带有mmc命令）：
        mmc bootbus set <boot_mode> <reset_boot_bus_conditions> <boot_bus_width> <device>
        Set Boot Bus Conditions.
        <boot_mode> must be "single_backward|single_hs|dual"
        <reset_boot_bus_conditions> must be "x1|retain"
        <boot_bus_width> must be "x1|x4|x8"
                
        mmc bootbus set single_backward x1 x1 /dev/mmcblk1
                
  mmc bootbus set single_backward x1 x1 /dev/mmcblk1

   3). 对eMMC进行分区操作：

```
在u-boot下分区：

setenv emmc_part "name=ssbl,size=2MiB;name=bootfs,type=linux,bootable,size=64MiB;name=vendorfs,type=linux,size=16MiB;name=rootfs,type=linux,size=746MiB;name=userfs,type=linux,size=700MiB"

gpt write mmc 1 $emmc_part

如果是Linux下分区，则操作为：
sgdisk --resize-table=128 -a 1 -n 1:34:4129 -c 1:ssbl -p /dev/mmcblk1                      //u-boot
sgdisk --resize-table=128 -a 1 -n 2:4130:135201 -c 2:bootfs -p /dev/mmcblk1                //bootfs
sgdisk --resize-table=128 -a 1 -n 3:135202:167969 -c 3:vendorfs -p /dev/mmcblk1            //vendor
sgdisk --resize-table=128 -a 1 -n 4:167970:1695777 -c 4:rootfs -p /dev/mmcblk1             //rootfs
sgdisk --resize-table=128 -a 1 -n 5:1695778:3129377 -c 5:userfs -p /dev/mmcblk1            //userfs

改变分区的类型可以用以下命令：
sgdisk -t 1:0700 /dev/mmcblk1

分区完成后，格式化相应分区：

mkfs -t ext4 /dev/mmcblk1p2
mkfs -t ext4 /dev/mmcblk1p3
mkfs -t ext4 /dev/mmcblk1p4
mkfs -t ext4 /dev/mmcblk1p5
```

   4). 将分区映像文件dd至各自对应分区中：

```
dd if=sanway-bootfs-stm32mp153a-swa1530.ext4 of=/dev/mmcblk1p2 conv=fdatasync
dd if=sanway-vendorfs-stm32mp153a-swa1530.ext4 of=/dev/mmcblk1p3 conv=fdatasync
dd if=sanway-rootfs-stm32mp153a-swa1530.ext4 of=/dev/mmcblk1p4 conv=fdatasync
dd if=sanway-emmc-user_local-20200825.ext4 of=/dev/mmcblk1p5 conv=fdatasync
```    

   5). SD卡上的分区信息：

    /dev/mmcblk0p1      34     545     512   256K Linux reserved        //ssbl
    /dev/mmcblk0p2     546    1057     512   256K Linux reserved        //ssbl
    /dev/mmcblk0p3    1058    5153    4096     2M Linux reserved        //u-boot
    /dev/mmcblk0p4    5154  136225  131072    64M Linux filesystem      //bootfs
    /dev/mmcblk0p5  136226  168993   32768    16M Linux filesystem      //vendor
    /dev/mmcblk0p6  168994 1705857 1536864 750.4M Linux filesystem      //rootfs
    /dev/mmcblk0p7 1705858 3145694 1439837   703M Linux filesystem      //userfs

    注意！当映像写入完成后，SD卡启动之前还需要进行一步设置：
    sudo sgdisk -A 4:set:2 /dev/sde    //数字4表示选择第4个分区进行设置，set:2表示设置为2
    否则SD启动时U-boot不识别bootfs分区。

6). 如果是想采用ubuntu18.04的SD卡，则分区信息为（32GB SD卡）：

    Disk /dev/sde: 61157376 sectors, 29.2 GiB
    Model: Storage Device  
    Sector size (logical/physical): 512/512 bytes
    Disk identifier (GUID): 429EB42D-E473-48EE-B8B3-377E0BDCFA39
    Partition table holds up to 128 entries
    Main partition table begins at sector 2 and ends at sector 33
    First usable sector is 34, last usable sector is 61157342
    Partitions will be aligned on 2-sector boundaries
    Total free space is 3005 sectors (1.5 MiB)

    Number  Start (sector)    End (sector)  Size       Code  Name
       1              34             545   256.0 KiB   8301  fsbl1
       2             546            1057   256.0 KiB   8301  fsbl2
       3            1058            5153   2.0 MiB     8301  ssbl
       4            5154          136225   64.0 MiB    8300  bootfs
       5          136226          168993   16.0 MiB    8300  vendorfs
       6          168994         5100577   2.4 GiB     8300  rootfs
       7         5100578         9297919   2.0 GiB     0700  Linux data partition
       8         9297920        40757247   15.0 GiB    0700  Linux data partition
       9        40757248        61155327   9.7 GiB     0700  Linux data partition

    例如，进行GPT分区，设置第一个分区，需要带参数-g，后续则不需要：    
    sudo sgdisk -g --resize-table=128 -a 1 -n 1:34:545 -c 1:fsbl1 -p /dev/sde    
    
    如果删除分区：    
    sudo sgdisk -d 1 /dev/sde

    注意！当映像写入完成后，SD卡启动之前还需要进行一步设置：
    sudo sgdisk -A 4:set:2 /dev/sde    //数字4表示选择第4个分区进行设置，set:2表示设置为2
    否则SD启动时U-boot不识别bootfs分区。
  

4. 启动后可以用nfs来挂载电脑上的文件系统

        挂载时，用
        mount -t nfs 192.168.1.105:/ /mnt/nfs
        时出现
        svc: failed to register lockdv1 RPC service (errno 111)
        改为
        mount -t nfs -o nolock 192.168.1.105:/ /mnt/nfs 
        
5. 显示调试：
    
5.1. 需要修改DTB：
        
```
 // SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
/*
 * Copyright (C) i2SOM 2018 - All Rights Reserved
 * Author: Steve Chen <steve.chen@i2som.tech>.
 */

/dts-v1/;

#include "swa1530-eb-new.dts"

/ {
	model = "SANWAY swa530-eb Board LCD";
	compatible = "swa1530,sanway", "st,stm32mp157";

	panel_rgb: panel-rgb {
		compatible = "innolux,at070tn92";
		//compatible = "innolux,zj070na-01p";
		//compatible = "innolux,at043tn24";
		pinctrl-names = "default", "sleep";
		pinctrl-0 = <&ltdc_pins_b>;
		pinctrl-1 = <&ltdc_pins_sleep_b>;
		//backlight = <&panel_backlight>;
		status = "okay";

		port {
			panel_in_rgb: endpoint {
				remote-endpoint = <&ltdc_out_rgb>;
			};
		};
	};

};

&ltdc {
	status = "okay";

	port {
		#address-cells = <1>;
		#size-cells = <0>;

		ltdc_out_rgb: endpoint@1 {
			reg = <1>;
			remote-endpoint = <&panel_in_rgb>;
		};

	};
};
```
```
// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
/*
 * Copyright (C) i2SOM 2018 - All Rights Reserved
 * Author: Steve Chen <steve.chen@i2som.tech>.
 */

/dts-v1/;

#include "swa1530-eb-lcd.dts"

&panel_rgb {
	compatible = "innolux,at070tn92";
};
```


5.2. Linux开机logo居中和多只企鹅改一只 (2018-02-26 20:18:31)

    1、居中

    （1）修改源码/driver/video/fbmem.c中的fb_show_logo_line函数
        -image.dx=0;  
        -image.dy=y;  
        +image.dx = (info->var.xres / 2) - (image.width / 2);  
        +image.dy = (info->var.yres / 2) - (image.height / 2);  
        image.width = logo->width;  
        image.heigh = logo->height;  

    2、多只企鹅改一只
    修改drivers/video/fbmem.c中的fb_show_logo_line()函数
    
    -y = fb_show_logo_line(info, rotate, fb_logo.logo, 0, num_online_cpus());  
    +y = fb_show_logo_line(info, rotate, fb_logo.logo, 0, 1);  

5.3. touchscreen触摸屏采用TCU上用的USB触摸屏时，需要配置内核选项：

    Device Drivers --> Input device support --> Touchscreens --> USB Touchscreen Driver
    同时要修改EV_VERSION 为0x10000，在include/uapi/linux/input.h里

+ 还要修改源码：/drivers/input/touchscreen/usbtouchscreen.c:

```
/* device types */
enum {
	DEVTYPE_IGNORE = -1,
	DEVTYPE_EGALAX,
	DEVTYPE_PANJIT,
	DEVTYPE_3M,
	DEVTYPE_ITM,
	DEVTYPE_ETURBO,
	DEVTYPE_GUNZE,
	DEVTYPE_DMC_TSC10,
	DEVTYPE_IRTOUCH,
	DEVTYPE_IRTOUCH_HIRES,
	DEVTYPE_IDEALTEK,
	DEVTYPE_GENERAL_TOUCH,
	DEVTYPE_GOTOP,
	DEVTYPE_JASTEC,
	DEVTYPE_E2I,
	DEVTYPE_ZYTRONIC,
	DEVTYPE_TC45USB,
	DEVTYPE_NEXIO,
	DEVTYPE_ELO,
	DEVTYPE_ETOUCH,
	DEVTYPE_PENMOUNT,	//Jason.Wang: 2020-04-09, 添加PenMount的USB ID和读写函数
};
```

```
#ifdef CONFIG_TOUCHSCREEN_PENMOUNT_USB
	{USB_DEVICE(0x14e1, 0x6000), .driver_info = DEVTYPE_PENMOUNT},
#endif
```

```
/*****************************************************************************
 * PENMOUNT Part: Jason.Wang: 2020-04-09，添加PenMount读写代码
 */
#ifdef CONFIG_TOUCHSCREEN_PENMOUNT_USB
static int penmount_touch_read_data(struct usbtouch_usb *dev, unsigned char *pkt)
{
	//printk("PenMount pkt = 0x%x\n", (*pkt));
	dev->x = ((pkt[2] & 0x0f) << 8) | pkt[1];
	dev->y = ((pkt[4] & 0x0f) << 8) | pkt[3];
	dev->touch = (pkt[0] & 0x40) >> 6;
	return 1;
}
#endif
```
```
#ifdef CONFIG_TOUCHSCREEN_PENMOUNT_USB
	[DEVTYPE_PENMOUNT] = {
		.min_xc         = 0x0,
		.max_xc         = 0xfff,
		.min_yc         = 0x0,
		.max_yc         = 0xfff,
		.rept_size      = 5,
		.read_data      = penmount_touch_read_data,
	},
#endif
```
编译内核，此时插拔液晶屏，串口终端上可以看到有USB设备提示出现：
```
[ 3408.183040] usb 1-2.1: USB disconnect, device number 4
[ 3411.126896] usb 1-2.1: new full-speed USB device number 5 using ehci-platform
[ 3411.229561] input: DIALOGUE INC PenMount USB as /devices/platform/soc/5800d000.usbh-ehci/usb1/1-2/1-2.1/1-2.1:1.0/input/input2
```
内核中将找到的输入设备生成的设备文件为：

    /dev/input/event1

进入到/dev/input目录下，然后做一个链接：

    ln -s event1 touchscreen0

+ 运行ts_calibrate校准液晶屏，发现提示找不到输入设备，重新编译tslib-1.4版本的库，并复制到板子的/usr/lib目录下：

```
root@SWA1530:/dev# ll /usr/lib/libts*
lrwxrwxrwx 1 root    root    18 Oct 19 05:20 /usr/lib/libts-0.0.so.0 -> libts-1.4.so.0.2.4
lrwxrwxrwx 1 root    root    18 Oct 19 05:16 /usr/lib/libts-1.0.so.0 -> libts-1.4.so.0.2.4
lrwxrwxrwx 1 root    root    18 Oct 19 05:11 /usr/lib/libts-1.4.so.0 -> libts-1.4.so.0.2.4
-rwxr-xr-x 1 sanland 1000 52137 Apr 10  2020 /usr/lib/libts-1.4.so.0.2.4
-rwxr-xr-x 1 sanland 1000   977 Apr 10  2020 /usr/lib/libts.la
lrwxrwxrwx 1 root    root    18 Oct 19 05:11 /usr/lib/libts.so -> libts-1.4.so.0.2.4
```

注意为了兼容以前老的软件，需要将libts-1.4.so.0.2.4同时链接到libts-0.0.so.0和libts-1.0.so.0上。

6. FMC总线DTS配置代码：

        &fmc {
        pinctrl-names = "default", "sleep";
        pinctrl-0 = <&fmc_pins_a>;
        pinctrl-1 = <&fmc_sleep_pins_a>;
        status = "okay";
        #address-cells = <1>;
        #size-cells = <1>;
        /delete-property/interrupts;
        /delete-property/dmas;
        /delete-property/dma-names;
        reg = <0x58002000 0x1000>;
        ranges;

        ebi {
                #address-cells = <2>;
                #size-cells = <1>;
                compatible = "st,stm32mp1-fmc2-ebi";
                ranges = <0 0 0x60000000 0x4000000>,
                         <1 0 0x64000000 0x4000000>,
                         <2 0 0x68000000 0x4000000>,
                         <3 0 0x6c000000 0x4000000>;

                ks8851mll@0 {
			status = "okay";
                        compatible = "micrel,ks8851-mll";
                        reg = <0 0x0 0x1 0 0x2 0x1>;
			//reg = <1 0x0 0x1 1 0x2 0x1>;
                        interrupt-parent = <&gpioa>;
                        //interrupts = <5 IRQ_TYPE_LEVEL_LOW>;
			interrupts = <5 IRQ_TYPE_EDGE_FALLING>;
                        bank-width = <2>;

                        /* Timing values are in nS */
                        // st,fmc2_ebi_cs_mux_enable;
                        // st,fmc2_ebi_cs_transaction_type = <4>;
                        // st,fmc2_ebi_cs_buswidth = <16>;
			st,fmc2_ebi_cs_transaction_type = <2>;	//外部接口为SRAM
                        st,fmc2_ebi_cs_buswidth = <16>;		//总线宽度16位

			/*读时序*/
                        st,fmc2_ebi_cs_address_setup = <6>;
                        st,fmc2_ebi_cs_address_hold = <6>;
                        st,fmc2_ebi_cs_data_setup = <80>;                        
                        st,fmc2_ebi_cs_data_hold = <20>;
			st,fmc2_ebi_cs_bus_turnaround = <50>;

			/*写时序*/
			st,fmc2_ebi_cs_write_address_setup = <6>;
			st,fmc2_ebi_cs_write_address_hold = <6>;
			st,fmc2_ebi_cs_write_data_setup = <80>;
			st,fmc2_ebi_cs_write_data_hold = <20>;
			st,fmc2_ebi_cs_write_bus_turnaround = <50>;
                };

		dm9000@1 {
			status = "okay";
			compatible = "davicom,dm9000";
			//FMC的SRAM模式地址起始：
			//CS1：0x6000_0000
			//CS2：0x6400_0000
			//CS3：0x6800_0000
			//CS4：0x6c00_0000
			
			reg = <1 0x0 0x2 1 0x8 0x2>;			
			//reg = <0 0x0 0x2 0 0x8 0x2>;			
			// interrupt-parent = <&gpioa>;
			// interrupts = <3 IRQ_TYPE_EDGE_FALLING>;
			irq_gpio = <&gpioa 3 IRQ_TYPE_EDGE_FALLING>;
			bank-width = <2>;
			
			//interrupt-names = "event";
			//interrupts-extended = <&intc GIC_SPI 9 IRQ_TYPE_LEVEL_HIGH>;
			//interrupts-extended = <&intc GIC_SPI 9 IRQ_TYPE_LEVEL_LOW>;
					      //<&exti 27 1>;
			local-mac-address = [00 00 de ad be ef];
			davicom,no-eeprom;
			//sanway,fiber;		//打开这句可以支持DM9000光纤模式

			/* Timing values are in nS */
                        //st,fmc2_ebi_cs_mux_enable;		//地址/数据线不复用，MODE A模式
                        st,fmc2_ebi_cs_transaction_type = <2>;	//外部接口为SRAM
                        st,fmc2_ebi_cs_buswidth = <16>;

                        st,fmc2_ebi_cs_address_setup = <0>;
                        st,fmc2_ebi_cs_address_hold = <6>;
                        st,fmc2_ebi_cs_data_setup = <50>;                       
                        st,fmc2_ebi_cs_data_hold = <50>;
			st,fmc2_ebi_cs_bus_turnaround = <50>;

			st,fmc2_ebi_cs_write_address_setup = <0>;
			st,fmc2_ebi_cs_write_address_hold = <6>;
			st,fmc2_ebi_cs_write_data_setup = <20>;
			st,fmc2_ebi_cs_write_data_hold = <20>;
			st,fmc2_ebi_cs_write_bus_turnaround = <50>;
			};

		cpld@2 {
			status = "okay";
			compatible = "sanway,cpld";
			//FMC的SRAM模式地址起始：
			//CS1：0x6000_0000
			//CS2：0x6400_0000
			//CS3：0x6800_0000
			//CS4：0x6c00_0000
			reg = <2 0x0 0x10000>;
			bank-width = <1>;

			/* Timing values are in nS */
                        //st,fmc2_ebi_cs_mux_enable;
                        st,fmc2_ebi_cs_transaction_type = <2>;	//表示采用MODE-A模式
                        st,fmc2_ebi_cs_buswidth = <8>;		//总线宽度为8位
                        st,fmc2_ebi_cs_address_setup = <6>;	//地址线到CS片选拉低之间的建立时间
                        st,fmc2_ebi_cs_address_hold = <6>;	//地址保持时间，异步访问模式下不关心
                        st,fmc2_ebi_cs_data_setup = <127>;	//数据建立时间
                        st,fmc2_ebi_cs_bus_turnaround = <50>;	//两次总线访问之间的间隔时间
                        st,fmc2_ebi_cs_data_hold = <10>;	//在片选拉高之前的数据保持时间
		};
	
		//CS3采用8位总线，MODE-A访问模式，注意4路串口的时序必须设置的完全一样
		serial8250@3,0 {
			status = "okay";
			compatible = "ns16550a";				
			reg = <3 0 0x8>;					
			bank-width = <1>;
			reg-shift = <0>;
			reg-io-width = <1>;
			clock-frequency = <14745600>;
			// interrupt-parent = <&gpiof>;
			// interrupts = <10 IRQ_TYPE_EDGE_RISING>;
			interrupt-parent = <&gpiod>;
			interrupts = <11 IRQ_TYPE_EDGE_RISING>;
			current-speed = <115200>;

			/* Timing values are in nS */
			//st,fmc2_ebi_cs_mux_enable;
			st,fmc2_ebi_cs_transaction_type = <2>;	//表示采用MODE-A模式
			st,fmc2_ebi_cs_buswidth = <8>;		//总线宽度为8位
			st,fmc2_ebi_cs_address_setup = <6>;	//地址线到CS片选拉低之间的建立时间
			st,fmc2_ebi_cs_address_hold = <6>;	//地址保持时间，异步访问模式下不关心
			st,fmc2_ebi_cs_data_setup = <127>;	//数据建立时间
			st,fmc2_ebi_cs_bus_turnaround = <50>;	//两次总线访问之间的间隔时间
			st,fmc2_ebi_cs_data_hold = <10>;	//在片选拉高之前的数据保持时间				
		};

		serial8250@3,1 {
			status = "okay";
			compatible = "ns16550a";				
			reg = <3 0x8 0x8>;					
			bank-width = <1>;
			reg-shift = <0>;
			reg-io-width = <1>;
			clock-frequency = <14745600>;
			interrupt-parent = <&gpiod>;
			interrupts = <11 IRQ_TYPE_EDGE_RISING>;
			current-speed = <115200>;

			/* Timing values are in nS */
			//st,fmc2_ebi_cs_mux_enable;
			st,fmc2_ebi_cs_transaction_type = <2>;	//表示采用MODE-A模式
			st,fmc2_ebi_cs_buswidth = <8>;		//总线宽度为8位
			st,fmc2_ebi_cs_address_setup = <6>;	//地址线到CS片选拉低之间的建立时间
			st,fmc2_ebi_cs_address_hold = <6>;	//地址保持时间，异步访问模式下不关心
			st,fmc2_ebi_cs_data_setup = <127>;	//数据建立时间
			st,fmc2_ebi_cs_bus_turnaround = <50>;	//两次总线访问之间的间隔时间
			st,fmc2_ebi_cs_data_hold = <10>;	//在片选拉高之前的数据保持时间				
		};	

		serial8250@3,2 {
			status = "okay";
			compatible = "ns16550a";				
			reg = <3 0x10 0x8>;					
			bank-width = <1>;
			reg-shift = <0>;
			reg-io-width = <1>;
			clock-frequency = <14745600>;
			interrupt-parent = <&gpiod>;
			interrupts = <12 IRQ_TYPE_EDGE_RISING>;
			current-speed = <115200>;

			/* Timing values are in nS */
			//st,fmc2_ebi_cs_mux_enable;
			st,fmc2_ebi_cs_transaction_type = <2>;	//表示采用MODE-A模式
			st,fmc2_ebi_cs_buswidth = <8>;		//总线宽度为8位
			st,fmc2_ebi_cs_address_setup = <6>;	//地址线到CS片选拉低之间的建立时间
			st,fmc2_ebi_cs_address_hold = <6>;	//地址保持时间，异步访问模式下不关心
			st,fmc2_ebi_cs_data_setup = <127>;	//数据建立时间
			st,fmc2_ebi_cs_bus_turnaround = <50>;	//两次总线访问之间的间隔时间
			st,fmc2_ebi_cs_data_hold = <10>;	//在片选拉高之前的数据保持时间				
		};

		serial8250@3,3 {
			status = "okay";
			compatible = "ns16550a";				
			reg = <3 0x18 0x8>;					
			bank-width = <1>;
			reg-shift = <0>;
			reg-io-width = <1>;
			clock-frequency = <14745600>;
			// interrupt-parent = <&gpiod>;
			// interrupts = <13 IRQ_TYPE_EDGE_RISING>;
			interrupt-parent = <&gpiod>;
			interrupts = <12 IRQ_TYPE_EDGE_RISING>;
			current-speed = <115200>;

			/* Timing values are in nS */
			//st,fmc2_ebi_cs_mux_enable;
			st,fmc2_ebi_cs_transaction_type = <2>;	//表示采用MODE-A模式
			st,fmc2_ebi_cs_buswidth = <8>;		//总线宽度为8位
			st,fmc2_ebi_cs_address_setup = <6>;	//地址线到CS片选拉低之间的建立时间
			st,fmc2_ebi_cs_address_hold = <6>;	//地址保持时间，异步访问模式下不关心
			st,fmc2_ebi_cs_data_setup = <127>;	//数据建立时间
			st,fmc2_ebi_cs_bus_turnaround = <50>;	//两次总线访问之间的间隔时间
			st,fmc2_ebi_cs_data_hold = <10>;	//在片选拉高之前的数据保持时间				
		};		              		              	              
        };
        };

7. 经过测试，FMC总线上挂载的ST16C554，是可以采用上升沿中断，并按照中断共享的模式使用的。

8. extlinux.conf问题：
        
发现uboot在读取extlinux.conf菜单时，如果此时手动按下“Enter”按键，会导致系统启动停止，等待用户选择驱动菜单。可以修改extlinux.conf文件，如下所示：
        
        #menu title Select the boot mode
        #MENU BACKGROUND /splash.bmp
        #TIMEOUT 20
        DEFAULT swm1244-1024x600
        LABEL swa1530-800x480
	        KERNEL /uImage
	        FDT /swa1530-eb-lcd-800x480.dtb
	        APPEND root=/dev/mmcblk1p4 rootwait rw console=ttySTM0,115200
        LABEL swm1244-1024x600
	        KERNEL /uImage
	        FDT /swm1244-eb-lcd-1024x600.dtb
	        APPEND root=/dev/mmcblk1p4 rootwait rw console=ttySTM0,115200
即将menu，MENU，TIMTEOUT等注释掉，则系统启动不再出现选择，直接引导Linux。

9. uboot支持网络tftp：

默认情况下，uboot.env环境变量中未配置MAC地址，此时在U-boot命令行下面网络时不通的，需要配置以下环境变量：

        setenv ethaddr  86:75:0e:45:3b:29
        setenv ipaddr 192.168.1.233
        setenv serverip 192.168.1.85
将这几个环境变量设置好之后，就可以直接使用tftp下载功能了。

10. 