2025-03-11：

## 采用我司SWA3568J申请南网电鸿测试时的注意事项：

1、需要填写测试申请表，表格文档样例：

[电鸿物联操作系统终端适配表](/media/sf_D_DRIVE/BaiduNetdiskWorkspace/Linux_work/RK3568相关_20240311/电鸿PEE测试相关_20250308/宁波三星/电鸿物联操作系统终端适配申请表（SXDCF48）.docx)

这个文档中，填写时需要注意事先先填好以下内容（橙色框线部分）：

![](/media/sf_D_DRIVE/BaiduNetdiskWorkspace/VNote笔记本_20200401/我的笔记本/RK3568相关/vx_images/a8a2bf3a85d8df024d5b6d19bc1902e.jpg)

| 设备名称/型号                             | 直流一体式充电机/SXDCF48                         | 客户提供设备名称和型号                       |
| ----------------------------------------- | ------------------------------------------------ | -------------------------------------------- |
| 设备主控规格-CPU/MCU型号                  | RockChip/RK3568J                                 |                                              |
| 设备主控当前操作系统以及版本              | Linux5.10.0                                      |                                              |
| **设备主控规格-RAM大小**                  | 2G                                               |                                              |
| **设备主控规格-ROM大小**                  | 16G                                              |                                              |
| 通信模组芯片规格及型号                    | 移远通信/EC200A-CN                               | 由我司提供模组的名称和型号                   |
| **通信模组**                              | 蓝牙  WAPI  星闪  ■4G  5G  Tpunb 无   其他：     | 如果有模组，则勾选，我司提供的设备一般为“4G” |
| 适配模式及适配版本 （本项由适配中心填写） | PHM    PHS    PHR     PEE    PES 适配模式： | 该项需要勾选“PEE”                            |

------

我这边重新改了一下soc_info.c驱动代码，可以实现直接读取/etc/soc_info中的信息作为SOC的ID号。代码如下：

```c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/device.h>
#include <linux/sysfs.h>
#include <linux/kobject.h>
#include <linux/slab.h>
//#include <asm/io.h>
#include <linux/fs.h>
#include <linux/init.h>
#include <linux/uaccess.h>

//必须添加以下这个名字空间，否则无法编译为module模式
//因为代码用到了kernel_read和filp_open这两个访问用户空间的函数
MODULE_IMPORT_NS(VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver);

extern char rockchip_cpu_soc_id[128];
//此处添加鸿蒙要求读取soc_info的定义
#define SOC_INFO_CLASS_NAME "dev_info"
static struct class *soc_info_class;
// static struct device *soc_info_device;

// 定义用户空间soc_info文件路径
//“etc/soc_info”的内容是一个16位的16进制数，类似于：0x373712120c465532，表示的是CPU的ID号
#define SOC_INFO_FILE_PATH "/etc/soc_info"

struct soc_info_struct {
    u8 read_success;
    u8 buffer[256];
};

static struct soc_info_struct g_soc_info;
static struct soc_info_struct *p_soc_info = &g_soc_info;

// show函数，用于读取属性值
static ssize_t soc_info_show(struct class *class, struct class_attribute *attr, char *buf)
{
    if (p_soc_info->read_success) {
        return sprintf(buf, "soc sn:%s", p_soc_info->buffer);
    }
    
    return sprintf(buf, "soc sn:0x%s\\n", rockchip_cpu_soc_id);
}

// 定义设备属性
static CLASS_ATTR_RO(soc_info);

// static struct attribute *soc_info_attrs[] = {
    // &class_attr_soc_info.attr,
    // NULL,
// };

// static struct attribute_group soc_info_attr_group = {
    // .attrs = soc_info_attrs,
// };

// static const struct attribute_group *soc_info_attr_groups[] = {
    // &soc_info_attr_group,
    // NULL,
// };

static int get_user_space_file(char *file_name, char *buf, int len)
{
	struct file *filp;
	loff_t pos;
	int ret = -1;

	filp = filp_open(file_name, O_RDWR, 0644);
	if (IS_ERR(filp)) {
		pr_err("%s: %s opened failed.\\n", __FUNCTION__, file_name);
		return -1;
	}

	pos = 0;
	ret = kernel_read(filp, buf, len, &pos);
	if (ret <= 0) {
        filp_close(filp, NULL);
		pr_err("%s: kernel_read failed.\\n", __FUNCTION__);
		return -1;
	}

#if 0
	pr_info("buf: %s\\n", buf);
#endif
	filp_close(filp, NULL);
	return 0;
}

static int __init soc_info_init(void)
{
    int ret;

    ret = get_user_space_file(SOC_INFO_FILE_PATH, p_soc_info->buffer, sizeof(p_soc_info->buffer));
    p_soc_info->read_success = (ret < 0) ? 0 : 1;

    // 创建一个类
    soc_info_class = class_create(THIS_MODULE, SOC_INFO_CLASS_NAME);
    if (IS_ERR(soc_info_class)) {
        pr_err("Failed to create class\\n");
        return PTR_ERR(soc_info_class);
    }

    // 添加属性组到类
    ret = class_create_file(soc_info_class, &class_attr_soc_info);
    if (ret) {
        pr_err("Failed to create class attribute\\n");
        class_destroy(soc_info_class);
        return ret;
    }

    pr_info("soc_info: created in /sys/class/%s\\n", SOC_INFO_CLASS_NAME);
    return 0;
}

static void __exit soc_info_exit(void)
{
    // 删除类属性
    class_remove_file(soc_info_class, &class_attr_soc_info);

    // 销毁类
    class_destroy(soc_info_class);

    pr_info("soc_info: removed from /sys/class/%s\\n", SOC_INFO_CLASS_NAME);
}

/*  此处将module_init和module_exit替换为late_initcall和module_exit
    目的是为了保证在系统启动完成后再执行此module
*/

//module_init(soc_info_init);
//late_initcall(soc_info_init);
late_initcall_sync(soc_info_init);
module_exit(soc_info_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("RAY.Wang");
MODULE_DESCRIPTION("A simple example of creating /sys/class nodes with read/write attributes");
```

------

2025-03-08：

按照刘天鹏给的信息，测试前准备的工作包含以下几点：

```c
1、实现《pee-license基础适配指令.xlsx》中要求接口信息，见《pee测试前准备处理.zip》
2、pee v1.0要求打两个补丁：0001-add-PEE-string-in-version.patch、linux-openeuler.bbappend,见《pee测试前准备处理.zip》
3、请厂商在设备pee系统自启动脚本中设置cp /mnt/system.license到/tmp/sysinfo/system.license，至于/mnt/system.license系统证书文件请先直接手动创建一个
```

**同时需要做以下几点修改：**

1、内核添加iptables过滤，已经编译到内核中并通过；

2、审计功能检测失败，目前发现需要将overlayfs关闭，采用默认的文件系统才能在systemd下启动auditd，启动之后检测审计功能成功；

3、/etc/ssh/sshd_config配置文件需要做以下修改：

```c
PermitEmptyPasswords no
PermitRootLogin no
```

4、内核版本号需要做修改：

```bash
dgri:~# uname -a
Linux dgri 5.10.0(1.0.1P)-PEE #80-PEE SMP PREEMPT Sat Mar 8 13:27:17 CST 2025 aarch64 GNU/Linux
```

这样运行检测程序之后，还余下两项未通过：

**系统证书合规性检测这一项检测不通过，是我的代码出现的问题：**

需要读取的为下面的内容，也就是“soc_sn  :”需要改为“soc sn :”，最后打印的信息如下：

```bash
dgri:~# cat /sys/class/dev_info/soc_info
soc sn:0x6bed246f7f5c1bea
执行：系统分区一致性检测。。。		成功！
执行：用户分区一致性检测。。。		成功！
执行：内核一致性检测。。。		成功！
执行：init系统一致性检测。。。		成功！
执行：系统完整性检测。。。		成功！
执行：系统版本合规性检测。。。		成功！
**执行：系统证书合规性检测。。。		失败！**
执行：网络高危端口检测。。。		成功！
执行：ssh安全性检测。。。		成功！
执行：多用户分级权限检测。。。		成功！
执行：网络防火墙检测。。。		成功！
执行：ACL权限管理检测。。。		成功！
执行：数据安全性检测。。。		成功！
执行：禁止root登录检测。。。		成功！
执行：身份鉴别安全检测。。。		成功！
执行：会话超时检测。。。		成功！
执行：安全启动检测。。。		不适用！
执行：cpu压力及散热测试。。。		成功！
执行：内存压力测试。。。		成功！
执行：磁盘IO压力测试。。。		成功！
执行：多任务压力测试。。。		成功！
执行：系统开机时间检测。。。		成功！
执行：文件系统性能检测。。。		成功！
执行：内存带宽测试。。。		成功！
执行：进程切换性能检测。。。		成功！
执行：硬件资源信息检测。。。		成功！
执行：接口资源信息检测。。。		成功！
执行：系统资源使用率检测。。。		成功！
执行：系统运行状态检测。。。		成功！
执行：日志审计检测。。。		成功！
执行：日志轮转检测。。。		成功！
执行：NTP对时功能检测。。。		成功！
执行：动态调频调压检测。。。		成功！
执行：文件系统类型检测。。。		成功！
执行：应用加载和守护。。。		不适用！
执行：系统在线升级。。。		不适用！
执行：系统配置文件备份。。。		不适用！
执行：存储空间监测与恢复。。。		不适用！
执行：内存泄漏监测与恢复。。。		成功！
执行：开机自检与恢复。。。		不适用！
执行：系统分区一致性检测。。。		成功！
执行：用户分区一致性检测。。。		成功！
```

**还有一项文件系统性能测试未通过，经过小刘的研究，发现需要设置RK3568的CPU运行于性能模式才能通过。**

因为CPU供电采用的是PMIC动态电源供电，因此，默认情况下，如果系统的负载较轻的话，则CPU会自动降频运行。因此，需要将CPU调整到最高性能模式。

可以这样来操作：

```bash
dgri:~# echo performance > /sys/bus/cpu/devices/cpu0/cpufreq/scaling_governor 
dgri:~# cat /sys/bus/cpu/devices/cpu0/cpufreq/scaling_governor 
performance
dgri:~# cat /sys/bus/cpu/devices/cpu0/cpufreq/cpuinfo_cur_freq 
1992000
```

5、另外，启动了iptables网络过滤之后，默认会关闭ftp、telnet和ssh远程端口，如果要将其打开，则需要设置过滤规则。

修改配置文件：/etc/sysconfig/iptables文件：

```bash
-A INPUT -p tcp -m state --state NEW -m tcp --dport 35521 -j ACCEPT
-A INPUT -p tcp -m state --state NEW -m tcp -m multiport --sport 1024:65535 -j ACCEPT
-A INPUT -p tcp -m state --state NEW -m tcp --dport 35522 -j ACCEPT
-A INPUT -p tcp -m state --state NEW -m tcp --dport 35523 -j ACCEPT
```

**为了安全起见，系统不允许root登录，而改为：**

```bash
用户名：sanway  
密码：szsw@1929
```

**默认远程端口更改为：**

```bash
ssh端口号35522
ftp端口号35521
telnet端口号35523
```

------

2025-02-27：

按照宁波三星的需求，南网电鸿需要修改以下内容：

[pee测试前准备处理(7).zip](attachment:5aa91353-472c-4f4d-ae74-23687ab471fd:pee测试前准备处理(7).zip)

## 1、获取SOC芯片的ID：

```bash
cat /sys/class/dev_info/soc_info
```

需要增加驱动来实现。方案如下：

### 1）在内核代码：/media/jason/rockchip/kernel/drivers/soc/rockchip/rockchip-cpuinfo.c中，将SOC的序列号导出：

```c
char rockchip_cpu_soc_id[128];
EXPORT_SYMBOL(rockchip_cpu_soc_id);

...

#ifdef CONFIG_NO_GKI
	system_serial_low = crc32(0, buf, 8);
	system_serial_high = crc32(system_serial_low, buf + 8, 8);

	dev_info(dev, "Serial\\t\\t: %08x%08x\\n",
		 system_serial_high, system_serial_low);

	sprintf(rockchip_cpu_soc_id, "%08x%08x", system_serial_high, system_serial_low);
#endif
```

### 2）新增一个驱动：/media/jason/rockchip/kernel/drivers/char/cpld_sanway/soc_info/soc_info.c，代码如下：

注意！电鸿测试要求读取的目录为：/sys/class/dev_info/soc_info

```c
dgri:~# cat /sys/class/dev_info/soc_info
soc_sn  : 0x6bed246f7f5c1bea
```

------

2025-03-07：

现在的代码可以满足要求：

```c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/device.h>
#include <linux/sysfs.h>
#include <linux/kobject.h>
#include <linux/slab.h>

extern char rockchip_cpu_soc_id[128];
//此处添加鸿蒙要求读取soc_info的定义
#define SOC_INFO_CLASS_NAME "dev_info"
#define SOC_INFO_DEVICE_NAME "soc_info"

static struct class *soc_info_class;
// static struct device *soc_info_device;

// show函数，用于读取属性值
static ssize_t soc_info_show(struct class *class, struct class_attribute *attr, char *buf)
{
    return sprintf(buf, "soc_sn\\t: 0x%s\\n", rockchip_cpu_soc_id);
}

// 定义设备属性
static CLASS_ATTR_RO(soc_info);

// static struct attribute *soc_info_attrs[] = {
    // &class_attr_soc_info.attr,
    // NULL,
// };

// static struct attribute_group soc_info_attr_group = {
    // .attrs = soc_info_attrs,
// };

// static const struct attribute_group *soc_info_attr_groups[] = {
    // &soc_info_attr_group,
    // NULL,
// };
// 
static int __init soc_info_init(void)
{
    int ret;

    // 创建一个类
    soc_info_class = class_create(THIS_MODULE, SOC_INFO_CLASS_NAME);
    if (IS_ERR(soc_info_class)) {
        pr_err("Failed to create class\\n");
        return PTR_ERR(soc_info_class);
    }

    // 添加属性组到类
    ret = class_create_file(soc_info_class, &class_attr_soc_info);
    if (ret) {
        pr_err("Failed to create class attribute\\n");
        class_destroy(soc_info_class);
        return ret;
    }

    pr_info("soc_info: created in /sys/class/%s\\n", SOC_INFO_CLASS_NAME);
    return 0;
}

static void __exit soc_info_exit(void)
{
    // 删除类属性
    class_remove_file(soc_info_class, &class_attr_soc_info);

    // 销毁类
    class_destroy(soc_info_class);

    pr_info("soc_info: removed from /sys/class/%s\\n", SOC_INFO_CLASS_NAME);
}

module_init(soc_info_init);
module_exit(soc_info_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("RAY.Wang");
MODULE_DESCRIPTION("A simple example of creating /sys/class nodes with read/write attributes");
```

下面之前的代码实现最终要在/sys/class/dev_info/soc_info/soc_info下才能获取，不满足电鸿测试的要求。

------

```c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/device.h>
#include <linux/sysfs.h>
#include <linux/kobject.h>
#include <linux/slab.h>

extern char rockchip_cpu_soc_id[128];
//此处添加鸿蒙要求读取soc_info的定义
#define SOC_INFO_CLASS_NAME		"dev_info"
#define SOC_INFO_DEVICE_NAME		"soc_info"
static struct class *soc_info_class;
static struct device *soc_info_device;

// show函数，用于读取属性值
static ssize_t soc_info_show(struct device *dev, struct device_attribute *attr, char *buf)
{
    return sprintf(buf, "soc_sn\\t: 0x%s\\n", rockchip_cpu_soc_id);
}
// 定义设备属性
static DEVICE_ATTR_RO(soc_info);

static struct attribute *soc_info_control_attrs[] = {
	&dev_attr_soc_info.attr,	
	NULL,
};
ATTRIBUTE_GROUPS(soc_info_control);

static int __init soc_info_init(void)
{
    int ret;

    // 创建一个类
    soc_info_class = class_create(THIS_MODULE, SOC_INFO_CLASS_NAME);
    if (IS_ERR(soc_info_class)) {
        pr_err("Failed to create class\\\\n");
        return PTR_ERR(soc_info_class);
    }

    // 创建一个设备
    soc_info_device = device_create(soc_info_class, NULL, 0, NULL, SOC_INFO_DEVICE_NAME);
    if (IS_ERR(soc_info_device)) {
        pr_err("Failed to create device\\\\n");
        class_destroy(soc_info_class);
        return PTR_ERR(soc_info_device);
    }

    // 创建设备属性文件
    // ret = device_create_file(soc_info_device, &dev_attr_soc_info);
    // if (ret) {
        // pr_err("Failed to create device attribute\\\\n");
        // device_destroy(soc_info_class, 0);
        // class_destroy(soc_info_class);
        // return ret;
    // }

    ret = devm_device_add_groups(soc_info_device, soc_info_control_groups);
	if (ret) {
	    pr_err("Could not add attribute: soc_info_control group!\\n");
        device_destroy(soc_info_class, 0);
        class_destroy(soc_info_class);
        return ret;
    }

    pr_info("OK\\n");
    return 0;
}

static void __exit soc_info_exit(void)
{
    // 删除设备属性文件
    // device_remove_file(soc_info_device, &dev_attr_soc_info);
    // 销毁设备和类
    device_del(soc_info_device);
    device_destroy(soc_info_class, 0);
    class_destroy(soc_info_class);
    pr_info("Bye\\n");
}

module_init(soc_info_init);
module_exit(soc_info_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("RAY.Wang");
MODULE_DESCRIPTION("A simple example of creating /sys/class nodes with read/write attributes");
```

### 3）然后重新编译内核，重启系统，用以下命令查看：

```bash
root@SWM4696:~# cat /sys/class/dev_info/soc_info/soc_info
soc_sn  : 0x6bed246f7f5c1bea
```

## 2、内核版本号需要打上“-PEE”的标识：

配置内核：

```bash
./make_menuconfig_arm64
General setup  --->
	(-PEE) Local version - append to kernel release
```

退出配置界面，保存配置：

```bash
./make_default_menu_arm64
```

然后重新编译内核即可。

该项目保存在虚拟机的目录：/media/jason/rockchip/sanway_20220812/dca801_20240615/鸿蒙PEE相关_20250227/下。