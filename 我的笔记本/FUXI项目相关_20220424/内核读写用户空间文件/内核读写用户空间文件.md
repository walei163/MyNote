# 内核读写文件

简介
 用户空间     内核空间
 open()       filp_open()
 close()       filp_close()
 read()       kernel_read()
 write()       kernel_write()

环境
 架构：[ARM](https://so.csdn.net/so/search?q=ARM&spm=1001.2101.3001.7020)
 内核版本：4.15

源码
 file.c

```c
#include <linux/fs.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/uaccess.h>
 
#define FILENAME "/tmp/kernel_file"
 
static char buf[] = "5555\n";
static char buf1[10] = {0};
 
int hello_init(void)
{
	struct file *filp;
	loff_t pos;
 
	printk("hello enter\n");
 
	filp = filp_open(FILENAME, O_RDWR | O_CREAT, 0644);
	if (IS_ERR(filp)) {
		printk("create file error\n");
		return -1;
	}
 
	pos = 0;
	kernel_write(filp, buf, sizeof(buf), &pos);
 
	pos = 0;
	kernel_read(filp, buf1, sizeof(buf1) - 1, &pos);
	printk("read: %s", buf1);
 
	filp_close(filp, NULL);
 
	return 0;
}
void hello_exit(void)
{
	printk("hello exit\n");
}
 
module_init(hello_init);
module_exit(hello_exit);
 
MODULE_LICENSE("GPL");
```

Makefile

```sh
obj-m:=file.o  
  
KDIR=/home/liyongjun/project/board/buildroot/Vexpress_4.15/build/linux-4.15.1/
CROSS_COMPILE=/home/liyongjun/project/board/buildroot/Vexpress_4.15/host/bin/arm-linux-
 
all:
	make -C $(KDIR) M=$(PWD) ARCH=arm CROSS_COMPILE=$(CROSS_COMPILE) modules
 
clean:
	make -C $(KDIR) M=$(PWD) ARCH=arm CROSS_COMPILE=$(CROSS_COMPILE) clean
 
```

#### 测试

```sh
# insmod file.ko 
hello enter
read: 5555
# 
# cat /tmp/kernel_file 
5555
```

---

# 内核模块编程对用户空间文件的访问

```c
/*
* HOW TO READ\WRITE THE FILE IN KERNEL MODULE
*/
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/string.h>
#include <linux/mm.h>
#include <linux/syscalls.h>
#include <asm/unistd.h>
#include <asm/uaccess.h>
#include <linux/slab.h>

#define FILE_PATH_READ "/usr/module/file_read_test"
//打开文件路径(包括文件名)，未来将要读的

#define FILE_PATH_WRITE "/usr/module/file_write_test"
//打开文件路径(包括文件名)，未来将要写的

struct file *file = NULL; //保存打开文件的文件指针变量
struct inode *inode = NULL; //为了获取文件大小用的inode结构变量
int *file_buf; //保存开辟的内存空间的地址的指针变量
loff_t fsize; //保存文件大小的变量
mm_segment_t old_fs; //保存内存边界的变量

/*
* kernel_file_open封装了文件打开函数
* 参数为文件路径(包含文件名)。
* 操作file类型结构变量。
* 打开方式为读写(没有则创建)
*/
static int kernel_file_open(char *file_path)
{
    file = filp_open(file_path,O_RDWR|O_CREAT,0);
    if (IS_ERR(file)) {
        printk("Open file %s failed./n", file_path);
        return 0;
      }
}

/*
* kernel_file_size封装了获取文件大小函数
* 参数为待获取大小的文件指针。
* 操作inode类型结构变量。
* 返回值为文件大小，单位字节
*/
static loff_t kernel_file_size(struct file *file)
{
    inode = file->f_dentry->d_inode;
    fsize = inode->i_size;
    printk(KERN_ALERT "size=%d/n",(int)fsize);
    return fsize;
}

/*
* kernel_addr_limit_expend封装了内存边界扩展函数
* 参数无。
*/
static int kernel_addr_limit_expend(void)
{
    old_fs = get_fs();
    set_fs(KERNEL_DS); 
    return 0;
}

/*
* kernel_addr_limit_resume封装了内存边界恢复函数
* 参数无。
*/
static int kernel_addr_limit_resume(void)
{
    set_fs(old_fs);
}

/*
* kernel_file_read封装了读文件函数
* 参数为open的文件指针，获取的文件大小
* 返回值为读入到内存中的首地址。
*/
void *kernel_file_read(struct file *file,loff_t fsize)
{
    int *buf;
    loff_t *pos = &(file->f_pos);
    buf = (int *)kmalloc(fsize+100,GFP_KERNEL);
    vfs_read(file, buf, fsize, pos);   
    printk("vfs_read=%s",buf);
    return buf;
}


/*
* kernel_file_ write封装了读文件函数
* 参数为open的文件指针，数据在内存中的地址，写入到文件的字节数
*/
static int kernel_file_write(struct file *file,int *buf,loff_t fsize)
{
    loff_t *pos = &(file->f_pos);
    vfs_write(file,buf,fsize,pos);
}


/*
* ko的主函数
*/
static int hello_init(void) //ko的主函数
{
    printk(KERN_ALERT "HOW TO ACCESEE THE FILE IN KERNEL MODULE/n");
    kernel_file_open(FILE_PATH_READ); //打开文件file_read_test
    kernel_file_size(file); //获取file_read_test的大小

    /*read file to mem*/
    kernel_addr_limit_expend(); //边界扩展
    file_buf = kernel_file_read(file,fsize); //读操作
    
    filp_close(file, NULL); //关闭文件file_read_test
    kernel_addr_limit_resume(); //边界恢复

    /*write mem to file*/
    kernel_file_open(FILE_PATH_WRITE); //打开文件new_file_test，没有则创建
    kernel_addr_limit_expend(); //边界扩展
    kernel_file_write(file,file_buf,fsize); //将前面读到内存中的数据，写入到文件new_file_test中
    
    filp_close(file, NULL); //关闭文件
    kernel_addr_limit_resume(); //边界恢复

    return 0;
}


static void hello_exit(void)
{
    printk(KERN_ALERT "CLEAN THE MODULE /n");
}


module_init(hello_init);
module_exit(hello_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("dead_angel");
MODULE_DESCRIPTION("ACCESS THE FILE IN KERNEL MODULE!"); 
```

