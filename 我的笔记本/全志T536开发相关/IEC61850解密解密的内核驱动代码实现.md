# IEC61850解密解密的内核驱动代码实现

为了便于61850代码加密计算，将加密放入内核驱动中实现，在用户层可以去掉`license.txt`文件。

**前提是：要在我司的核心板：SWA3568J和SWA536上才能使用。**

驱动目录：[/media/jason/btrfs_disk_M/Develop/allwinner/t536/V1.1/bsp/drivers/sanway/encode/](/media/jason/btrfs_disk_M/Develop/allwinner/t536/V1.1/bsp/drivers/sanway/encode/)

## 1. 驱动代码`encode.c`：

```c
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/cdev.h>
#include <asm/io.h>
#include <linux/fs.h>
#include <linux/init.h>
#include <linux/uaccess.h>
#include <linux/moduleparam.h>

#include "md5.c"

MODULE_IMPORT_NS(VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver);

#define SOC_ID_STRING	"373712120c465532"

static char *soc_id = SOC_ID_STRING;
module_param(soc_id, charp, S_IRUGO);
MODULE_PARM_DESC(soc_id, "SOC ID string, used as SOC_INFO property.");

#define DEBUG_ENCODE	0

#define MODULE_NAME		"encode"
#define FILE_NAME_MMC_CID	"/etc/cid"
#define FILE_NAME_LICENSE	"/etc/license.txt"
#define XOR_KEY			0xbc

static char rockchip_cpu_soc_id[128] = SOC_ID_STRING;
// static u8 buf1[256] = {0};
static char cid_buf[256] = {0};
static int sanway_encode_result = 0;

//这个函数在mmc.c中
extern int mmc_get_raw_cid(char *buf);

//此处添加鸿蒙要求读取soc_info的定义
#define SOC_INFO_CLASS_NAME "dev_info"
static struct class *soc_info_class;

static char soc_version_buf[256] = {0};

// show函数，用于读取属性值
static ssize_t soc_info_show(struct class *class, struct class_attribute *attr, char *buf)
{
//     if (p_soc_info->read_success) {
        // return sprintf(buf, "soc sn:%s", p_soc_info->buffer);
//     }
    
	//return sprintf(buf, "No id.\n");
	//return sprintf(buf, "soc sn:0x%s\n", rockchip_cpu_soc_id);
	return sprintf(buf, "soc sn:0x%s\n", rockchip_cpu_soc_id);
}

#define MAX_SOC_ID_LEN	16
static ssize_t soc_info_store(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
{
#if DEBUG_ENCODE
	pr_info("soc_info_store: buf: %s, count: %zu\n", buf, strnlen(buf, count));
#endif
	if(strnlen(buf, count) > MAX_SOC_ID_LEN) {
		strlcpy(rockchip_cpu_soc_id, buf, (MAX_SOC_ID_LEN + 1));		
	} else {
		pr_err("soc_id length too short, length >= %d\n", MAX_SOC_ID_LEN);
		return -EINVAL;
	}
	return count;
}

// 定义设备属性
static CLASS_ATTR_RW(soc_info);

static ssize_t soc_version_show(struct class *class, struct class_attribute *attr, char *buf)
{
	return sprintf(buf, "%s", soc_version_buf);
}

// 定义设备属性
static CLASS_ATTR_RO(soc_version);


static int xor_encode_str(u8 *buf, int len)
{	
	int i = 0;
	u8 tmp_buf[256];
	char buff1[256] = {0};
	char buff2[16] = {0};

	if (len <= 0) {
		return -1;
	}

	for (i = 0; i < (len - 1); i++) {
		tmp_buf[i] = buf[i] ^ XOR_KEY;
		sprintf(buff2, "0x%02x, ", tmp_buf[i]);
		strcat(buff1, buff2);
	}

	tmp_buf[i] = buf[i] ^ XOR_KEY;
	sprintf(buff2, "0x%02x", tmp_buf[i]);
	strcat(buff1, buff2);

#if DEBUG_ENCODE
	// pr_info("buf1: %s\n", buf1);
	pr_info("tmp_buf: %s\n", buff1);
#endif

	// if(strcmp(buf1, buff1) == 0) {
// #if DEBUG_ENCODE
		// pr_info("buf1 == buff1\n");
// #endif
		// return 0;
	// } else {
// #if DEBUG_ENCODE
		// pr_info("buf1 != buff1\n");
// #endif
		// return -1;
	// }

	strlcpy(soc_version_buf, buff1, sizeof(soc_version_buf));
	return 0;
}

static int generate_iec61850_code(char *mmc_cid)
{
	int read_len;
	int i;
	char temp[8] = {0};
	char hexbuf[256] = "12334567";
	unsigned char decrypt[16] = {0};
	unsigned char decrypt32[64] = {0};
	MD5_CTX md5c;	
	unsigned char md5_code1[16] = {0};	

	if (NULL == mmc_cid) {
		pr_err("cid error.\n");
		return -1;
	}

	sprintf(hexbuf, "%s", mmc_cid);
#if DEBUG_ENCODE
	pr_info("hexbuf: %s, len: %d\n", hexbuf, (int)strlen(hexbuf));
#endif

	//初始化
	MD5Init(&md5c);
	read_len = strlen(hexbuf);
	MD5Update(&md5c, (unsigned char *)hexbuf, (read_len - 1));
	MD5Final(&md5c, decrypt);
	strcpy((char *)decrypt32, "");

	for (i = 0; i < 16; i++) {
		sprintf(temp, "%02x", decrypt[i]);
		strcat((char *)decrypt32, temp);
		md5_code1[i] = decrypt[i];
	}	

#if DEBUG_ENCODE
	pr_info("md5: %s\n", decrypt32);
#endif
	return xor_encode_str(md5_code1, 16);	
}

/*
static int get_user_space_file(char *file_name, char *buf, int len)
{
	struct file *filp;
	loff_t pos;
	int ret = -1;

	filp = filp_open(file_name, O_RDWR, 0644);
	if (IS_ERR(filp)) {
		pr_err("%s opened error\n", __FUNCTION__);
		return -1;
	}

	pos = 0;
	ret = kernel_read(filp, buf, len, &pos);
	if (ret <= 0) {
		pr_err("kernel_read error\n");
		return -1;
	}

#if DEBUG_ENCODE
	pr_info("buf: %s\n", buf);
#endif
	filp_close(filp, NULL);

	return 0;
}
*/

int sanway_encode_successed(void)
{						
	return sanway_encode_result;
}
EXPORT_SYMBOL(sanway_encode_successed);

static int __init module_encode_init( void )
{			
	int ret = -1;
					
	if(!mmc_get_raw_cid(cid_buf)) {
		pr_info("mmc_get_raw_cid error\n");
		sanway_encode_result = -1;
		return -1;
	}

#if DEBUG_ENCODE
	pr_info("cid_buf: %s\n", cid_buf);
#endif

	// ret = get_user_space_file(FILE_NAME_LICENSE, buf1, sizeof(buf1));
	// if(ret < 0) {
		// pr_err("get_user_space_file error\n");
		// sanway_encode_result = -2;
		// return -1;
	// }

	ret = generate_iec61850_code(cid_buf);
	if(ret < 0) {
		pr_err("generate encode error\n");
		sanway_encode_result = -3;
		return -1;
	}

	// 创建一个类
    	soc_info_class = class_create(THIS_MODULE, SOC_INFO_CLASS_NAME);
    	if (IS_ERR(soc_info_class)) {
    	    pr_err("Failed to create class\n");
    	    return PTR_ERR(soc_info_class);
    	}

	// 添加属性到类
    	ret = class_create_file(soc_info_class, &class_attr_soc_info);
    	if (ret) {
    	    pr_err("Failed to create class_attr_soc_info attribute\n");
    	    class_destroy(soc_info_class);
    	    return ret;
    	}

	ret = class_create_file(soc_info_class, &class_attr_soc_version);
	if (ret) {
	    pr_err("Failed to create class_attr_soc_version attribute\n");
	    class_remove_file(soc_info_class, &class_attr_soc_info);
	    class_destroy(soc_info_class);
	    return ret;
	}

    	pr_info("soc_info: created in /sys/class/%s\n", SOC_INFO_CLASS_NAME);

	pr_info("module: %s installed.\n", MODULE_NAME);
	sanway_encode_result = 0;
	return 0;
}

static void __exit module_encode_exit( void )
{
	// 删除类属性
	class_remove_file(soc_info_class, &class_attr_soc_version);
    	class_remove_file(soc_info_class, &class_attr_soc_info);

    	// 销毁类
    	class_destroy(soc_info_class);

    	pr_info("soc_info: removed from /sys/class/%s\n", SOC_INFO_CLASS_NAME);
	pr_info("module: %s uninstalling.\n", MODULE_NAME);
}

//module_init(module_encode_init);
late_initcall(module_encode_init);
module_exit(module_encode_exit);

MODULE_LICENSE("GPL");
```

同时，还需要修改：`drivers/mmc/core/mmc.c`文件，目录：[/media/jason/btrfs_disk_M/Develop/allwinner/t536/V1.1/kernel/linux-5.10-origin/drivers/mmc/core/](/media/jason/btrfs_disk_M/Develop/allwinner/t536/V1.1/kernel/linux-5.10-origin/drivers/mmc/core/)

```c
//RAY.Wang: 2025-01-04，将MMC CID导出
static char mmc_cid_buf[256] = {0};
static u8 mmc_cid_export_successed = 0;
int mmc_get_raw_cid(char *buf)
{
	memcpy(buf, mmc_cid_buf, sizeof(mmc_cid_buf));
	return mmc_cid_export_successed;
}
EXPORT_SYMBOL(mmc_get_raw_cid);

/*
 * Given the decoded CSD structure, decode the raw CID to our CID structure.
 */
static int mmc_decode_cid(struct mmc_card *card)
    
...
    
static int mmc_init_card(struct mmc_host *host, u32 ocr,
	struct mmc_card *oldcard)
{
	struct mmc_card *card;
	int err;
	u32 cid[4];
	u32 rocr;
	char buf[256] = {0};
    
    ...
        
    //RAY.Wang: 2025-01-04，将MMC CID导出到全局变量mmc_cid_buf中。
    err = sprintf(buf, "%08x%08x%08x%08x\n",        
                  card->raw_cid[0],                 
                  card->raw_cid[1],                 
                  card->raw_cid[2],                 
                  card->raw_cid[3]);                
    if (err < 0) {                                  
            pr_warn("Get card cid number string failed.\n");
        mmc_cid_export_successed = 0;
    } else {  		
        pr_info("Get card index: [%d], name: [%s], cid: %s\n", card->host->index, mmc_hostname(card->host), buf);

        // if(card->host->index == 0) {
            memcpy(mmc_cid_buf, buf, sizeof(buf));
            mmc_cid_export_successed = 1;
            pr_info("mmc_cid_export_successed: %d, mmc_cid_buf: %s\n", mmc_cid_export_successed, mmc_cid_buf);
        // }
    }
```

## 2. 使用方法：

2025-06-30：

使用方法更新：

现在的代码可以直接编译进内核，然后通过以下方式来修改`SOC_INFO`中的ID值：

```sh
echo 36af5e85df9c1605 > /sys/class/dev_info/soc_info
```

修改成功的话，再进行读取，SOC_INFO就变为修改的值了：

```sh
# cat /sys/class/dev_info/soc_info
soc sn:0x36af5e85df9c1605
```

**注意：写入的字符串要大于16个字符，否则无法写入。**



---

将其编译为内核模块进行加载：`encode.ko`，加载时可以带上参数（如果不带参数则采用默认值），该参数就作为`SOC_INFO`的ID值：

```sh
insmod update_files/kernel/encode.ko soc_id=12345678aabbccdd
```

**注意：传递的参数为`16`个长度的字符串，可以带`“”`号，也可以不带引号。**

然后读取：

```sh
# cat /sys/class/dev_info/soc_info 
soc sn:0x12345678aabbccdd
```

同时还生成了内核中的61850的`license`：

```sh
# cat /sys/class/dev_info/soc_version
0xe6, 0x57, 0x06, 0xfe, 0xd9, 0xad, 0xde, 0x8a, 0xbe, 0x66, 0x3a, 0xc7, 0xc2, 0xd6, 0xe1, 0xf2# 
```

该`license`即作为`61850主程序`启动时的加密校验值。

**注意：可以将加载模块这个工作放入到`rc.user`中实现，同时`soc_id`的取值可以放到：`system.ini`中，增加一个字段即可。**

如下所示：

```sh
SOC_ID=12345678aabbccdd
```

