# DM-200[CPU-T5]-2508 V3.00调试说明

## 2025-09-22：

各通道采样数据：

![](/media/sf_D_DRIVE/BaiduNetdiskWorkspace/VNote笔记本_20200401/我的笔记本/全志T536开发相关/珠海万力达/微信图片_20250922135220_76_109.jpg)

外部端子与屏幕打印数据对应关系表：

|  外部端子丝印  | 程序打印通道号 | 备注说明 |
| :------------: | :------------: | :------: |
|       Ia       |     CH[08]     |          |
|       Ib       |     CH[10]     |          |
|       Ic       |     CH[05]     |          |
|       I0       |     CH[15]     |          |
|       IA       |     CH[12]     |          |
|       IB       |     CH[03]     |          |
|       IC       |     CH[01]     |          |
|       UA       |     CH[00]     |          |
|       UB       |     CH[02]     |          |
|       UC       |     CH[11]     |          |
|       U0       |     CH[13]     |          |
|      I0L       |     CH[04]     |          |
| DCIN（4~20mA） |     CH[07]     |          |
|                |                |          |

> 说明：
>
> 1、CH9和CH14通道硬件上连接到了5V，因此是固定数据。
>
> 2、CH6通道无数据。

---

## 2025-08-26：

### 1、原理图：

[/media/sf_D_DRIVE/BaiduNetdiskWorkspace/T536/珠海万力达_20250616/李山德项目/DM-200[CPU-T5]-2508 V3.00/DM-200[CPU-T5]-2508 V3.00/DM-200[CPU-T5].pdf](/media/sf_D_DRIVE/BaiduNetdiskWorkspace/T536/珠海万力达_20250616/李山德项目/DM-200[CPU-T5]-2508 V3.00/DM-200[CPU-T5]-2508 V3.00/DM-200[CPU-T5].pdf)

### 2、设备树文件：

[/media/jason/btrfs_disk_M/Develop/allwinner/t536/V1.1/device/config/chips/t536/dtbo/zhwld/dm-200-CPU-T5-2508-V3.00.dts](/media/jason/btrfs_disk_M/Develop/allwinner/t536/V1.1/device/config/chips/t536/dtbo/zhwld/dm-200-CPU-T5-2508-V3.00.dts)

### 3、调试说明：

#### 3.1. SPI-NOR Flash调试

如下图：

![image-20250826103130911](/media/sf_D_DRIVE/BaiduNetdiskWorkspace/VNote笔记本_20200401/我的笔记本/全志T536开发相关/珠海万力达/image-20250826103130911.png)

调试这个设备花费了一些时间。因此说明一下。

##### 1）设备树设计：

```c
spi2_pins_default: spi2@0 {
	pins = "PI7", "PI8", "PI9"; /* clk, mosi, miso */
	function = "spi2";
	drive-strength = <10>;
};
spi2_pins_cs: spi2@1 {
	pins = "PI6", "PI11", "PI10"; /* cs, hold, wp */
	//pins = "PI6"; /* cs, hold, wp */
	function = "spi2";
	drive-strength = <10>;
	bias-pull-up;
};
spi2_pins_sleep: spi2@2 {
	pins = "PI6", "PI7", "PI8", "PI9", "PI10", "PI11";
	//pins = "PI6", "PI7", "PI8", "PI9";
	function = "io_disabled";
};

...

//spi2
spi@4027000 {
	status = "okay";
	pinctrl-0 = <&spi2_pins_default &spi2_pins_cs>;
	pinctrl-1 = <&spi2_pins_sleep>;
	pinctrl-names = "default", "sleep";
	sunxi,spi-bus-mode = <SUNXI_SPI_BUS_NOR>;
	sunxi,spi-cs-mode = <SUNXI_SPI_CS_SOFT>;
	spidev@2 {
		status = "disabled";
	};
	
	flash: m25p80@0 {
		#address-cells = <1>;
		#size-cells = <1>;
		compatible = "spansion,m25p80", "jedec,spi-nor";
		reg = <0>;
		spi-max-frequency = <40000000>;
		m25p,fast-read;
		spi-rx-bus-width = <4>;
		spi-tx-bus-width = <4>;
		
		partitions {
			compatible = "fixed-partitions";
			#address-cells = <1>;
			#size-cells = <1>;
			rootfs@0 {
				label = "Fault_recording";
				// reg = <0x0 0xa00000>;	//10MB
				reg = <0x0 0x800000>;	//8MB
			};
		};
	};
};
```

其中，有几点需要注意：

```c
sunxi,spi-bus-mode = <SUNXI_SPI_BUS_NOR>;
sunxi,spi-cs-mode = <SUNXI_SPI_CS_SOFT>;
```

`spi-bus-mode`需要设置为：`SUNXI_SPI_BUS_NOR`，`sunxi,spi-cs-mode`需要设置为：`SUNXI_SPI_CS_SOFT`。

```c
spi-rx-bus-width = <4>;
spi-tx-bus-width = <4>;
```

`spi‑rx‑bus‑width/spi‑tx‑bus‑width`是 spi 的读写线宽，根据 Flash 特性可配置为 1/2/4。此处设置为：4，表示为`QSPI`模式。

##### 2）内核配置：

```sh
Device Drivers  --->
	<*> Memory Technology Device (MTD) support  ---> 
		Partition parsers  ---> 
			<*> OpenFirmware (device tree) partitioning parser
		<*>   Caching block device access to MTD devices
		<*>   SPI NOR device support  --->
			--- SPI NOR device support
			[*]   Use small 4096 B erase sectors
		
```

其中，“Caching block device access to MTD devices”这一项选中后，在文件系统的`/dev`目录下才会出现`mtdblock0`块设备。

- 如果设备树和内核配置均正确，则内核启动时会有如下打印信息：

```sh
[    1.352586] spi-nor spi2.0: found gd25q64, expected m25p80
[    1.357264] spi-nor spi2.0: gd25q64 (8192 Kbytes)
[    1.364852] 1 fixed-partitions partitions found on MTD device spi2.0
[    1.367956] Creating 1 MTD partitions on "spi2.0":
[    1.372718] 0x000000000000-0x000000800000 : "Fault_recording"
```

- 查看`/dev`目录下的设备：

```sh
# ll /dev/mtd*
crw-------    1 root     root       90,   0 Jan  1  1970 /dev/mtd0
crw-------    1 root     root       90,   1 Jan  1  1970 /dev/mtd0ro
brw-------    1 root     root       31,   0 Jan  1  1970 /dev/mtdblock0
```

- 查看/proc目录下的分区信息：

```sh
# cat /proc/mtd
dev:    size   erasesize  name
mtd0: 00800000 00001000 "Fault_recording"
```

##### 3）使用方法：

- **格式化设备：**

```sh
mkfs.ext4 /dev/mtdblock0
```

- **挂载分区：**

```sh
# mount /dev/mtdblock0 /usr/local/spi_flash/
[ 5105.094978] EXT4-fs (mtdblock0): mounted filesystem with ordered data mode. Opts: (null)
#

# df
Filesystem           1K-blocks      Used Available Use% Mounted on
/dev/mtdblock0            6588       178      5838   3% /usr/local/spi_flash
```

---

#### 3.2. GPIO调试

##### 1）DO测试：

为了便于在Linux系统下测试GPIO操作，我这边写了一个脚本`sanway_gpio.sh`：

```sh
#/bin/sh

CMD_GPIOSET=gpioset
CMD_GPIOGET=gpioget

SYSFS_GPIOCHIP0=/sys/kernel/debug/pinctrl/7096000.pinctrl/pinmux-pins
SYSFS_GPIOCHIP1=/sys/kernel/debug/pinctrl/3604000.pinctrl/pinmux-pins

if [ $# -lt 1 ]; then
    echo "Usage: $0 <pin_name> <value>"
    echo "Example: $0 PA5 1"
    exit 1
fi

GPIO_PIN_NAME=$1

#将参数全部转为大写
GPIO_PIN_NAME=$(echo "$GPIO_PIN_NAME" | tr '[:lower:]' '[:upper:]')
GPIO_PIN_VALUE=$2

GPIO_FIND_PIN=$(grep -w $GPIO_PIN_NAME $SYSFS_GPIOCHIP0 | awk -F: '{print $1}' | head -n 1)
if [ ! -z "$GPIO_FIND_PIN" ]; then
    echo "Pin $GPIO_PIN_NAME found in $SYSFS_GPIOCHIP0"
    GPIO_CHIP_NUMBER=0
else
    GPIO_FIND_PIN=$(grep -w $GPIO_PIN_NAME $SYSFS_GPIOCHIP1 | awk -F: '{print $1}' | head -n 1)
    if [ ! -z "$GPIO_FIND_PIN" ]; then
        echo "Pin $GPIO_PIN_NAME found in $SYSFS_GPIOCHIP1"
        GPIO_CHIP_NUMBER=1
    else
        echo "Pin $GPIO_PIN_NAME not found"
        exit 1
    fi
fi

GPIO_PIN_NUMBER=$(grep -w $GPIO_PIN_NAME $SYSFS_GPIOCHIP0 $SYSFS_GPIOCHIP1 | awk -F: '{print $2}' | awk '{print $2}')
if [ -z "$GPIO_PIN_NUMBER" ]; then
    echo "Pin $GPIO_PIN_NAME not found"
    exit 1
fi

#如果是gpiochip0，也就是从PL到PM，则pinnumber需要减去352
if [ $GPIO_CHIP_NUMBER -eq 0 ]; then
    GPIO_PIN_NUMBER=$(($GPIO_PIN_NUMBER - 352))
fi

echo "gpiochip$GPIO_CHIP_NUMBER: Pin_name: [$GPIO_PIN_NAME], Number: [$GPIO_PIN_NUMBER]"

if [ ! -z "$GPIO_PIN_VALUE" ]; then
    echo "Setting pin $GPIO_PIN_NAME to value $GPIO_PIN_VALUE"
    $CMD_GPIOSET $GPIO_CHIP_NUMBER $GPIO_PIN_NUMBER=$GPIO_PIN_VALUE
else
    echo "Getting pin $GPIO_PIN_NAME value: $($CMD_GPIOGET $GPIO_CHIP_NUMBER $GPIO_PIN_NUMBER)"
fi

exit 0
```

操作方法：

```sh
./sanway_gpio.sh PA0 1
```

就表示将PA0置1。

例如：操作图纸上的`DO14`，就可以写成以下模式：

```sh
./sanway_gpio.sh PL6 1; ./sanway_gpio.sh PL7 0; ./sanway_gpio.sh pm1 1
```

这样就将`DO14`这一路拉高了。

**注意，管脚名称不区分大小写。**

##### 2）DI测试：

上面的脚本运行时，不带设置值，则会返回当前GPIO的值：

```sh
# ./sanway_gpio.sh PA0    
Pin PA0 found in /sys/kernel/debug/pinctrl/3604000.pinctrl/pinmux-pins
gpiochip1: Pin_name: [PA0], Number: [0]
Getting pin PA0 value: 1
```

---

#### 3.3. PWM测试：

##### 1）配置

设计是采用`PWM0-0`来驱动ADC的`CONVST`脚进行采样，图纸如下：

![image-20250827165005080](/media/sf_D_DRIVE/BaiduNetdiskWorkspace/VNote笔记本_20200401/我的笔记本/全志T536开发相关/珠海万力达/image-20250827165005080.png)

`PWM0-0`对应到CPU的GPIO管脚：`PD23`，其设备树配置如下：

```sh
pwm0_0_pins_active: pwm0@0 {
	pins = "PD23";
	function = "pwm0_0";
};
pwm0_0_pins_sleep: pwm0@1 {
	pins = "PD23";
	function = "gpio_in";
	bias-pull-down;
};

...

//pwm0_0
pwm@2090010 {
	pinctrl-names = "active", "sleep";
	pinctrl-0 = <&pwm0_0_pins_active>;
	pinctrl-1 = <&pwm0_0_pins_sleep>;
	status = "okay";
};
```

Linux内核配置如下：

```sh
Allwinner BSP  ---> 
	Device Drivers  --->
		PWM Drivers  ---> 
			<*> PWM Support for Allwinner SoCs
			[*]   Enable pwm dynamic debug
			< > Soft-PWM Support for Allwinner SoCs 
```

##### 2）测试：

如果配置成功，则可以操作sysfs来进行测试：

```sh
# cd /sys/class/pwm/pwmchip0/
# ll
total 0      
lrwxrwxrwx    1 root     root           0 Aug 27 16:58 device -> ../../../2090000.pwm
--w-------    1 root     root        4.0K Aug 27 16:47 export
-r--r--r--    1 root     root        4.0K Aug 27 16:58 npwm
drwxr-xr-x    2 root     root           0 Aug 27 16:58 power
lrwxrwxrwx    1 root     root           0 Aug 27 16:58 subsystem -> ../../../../../../class/pwm
-rw-r--r--    1 root     root        4.0K Aug 27 16:58 uevent
--w-------    1 root     root        4.0K Aug 27 16:47 unexport
```

**第一步，export出`pwm0`设备：**

```sh
# echo 0 > export 
# ll
total 0      
lrwxrwxrwx    1 root     root           0 Aug 27 16:58 device -> ../../../2090000.pwm
--w-------    1 root     root        4.0K Aug 27 16:59 export
-r--r--r--    1 root     root        4.0K Aug 27 16:58 npwm
drwxr-xr-x    2 root     root           0 Aug 27 16:58 power
drwxr-xr-x    3 root     root           0 Aug 27 16:59 pwm0
lrwxrwxrwx    1 root     root           0 Aug 27 16:58 subsystem -> ../../../../../../class/pwm
-rw-r--r--    1 root     root        4.0K Aug 27 16:58 uevent
--w-------    1 root     root        4.0K Aug 27 16:47 unexport
```

如果export成功，则在该目录下会出现`pwm0`目录。

**第二步，进入`pwm0`目录下，设置周期和占空比：**

```sh
# cd pwm0/
# echo 100000 > period
# echo 90000 > duty_cycle 
# cat duty_cycle 
90000
```

> 注意：
>
> 周期和占空比的数字单位均为ns，上面的设置意思为：周期设置为100微秒，占空比设置为90微秒。
>
> 也就是在100微秒周期内，10微秒高电平，90微秒的低电平。

**第三步，使能`pwm0`：**

```sh
# echo 1 > enable 
```

> 如果都设置正确，此时测量电阻：`R231`，将会出现预期的方波波形。
>
> 并且，ADC的`BUSY`管脚（可以测量电阻：`R8`），也会出现同样周期的波形，说明ADC采样工作已经可以正确工作了。

##### 3）编程实现：

我从c-periphery项目源代码目录下抽出来的PWM操作实现代码，本质上还是对sysfs的读写操作。源代码目录：

[/media/jason/btrfs_disk_M/Develop/allwinner/sanway/pwm操作采用sysfs的程序代码/](/media/jason/btrfs_disk_M/Develop/allwinner/sanway/pwm操作采用sysfs的程序代码/)

在Linux系统下，运行`pwmtest`测试程序：

```sh
# ./pwmtest 0 100000 90000
```

将会达到和上一节一样的运行效果。

> `pwmtest`测试程序参数说明：
>
> - 参数1：表示要操作哪一路pwm，此处为0，表示操作`pwm0`；
>
> - 参数2：对应period，也就是设置周期；
>
> - 参数3：对应duty_cycle，也就是占空比。

#### 3.4. ADC调试：

##### 1）内核驱动：

程序代码路径：[/media/jason/btrfs_disk_M/Develop/allwinner/t536/V1.1/bsp/drivers/sanway/spi_adc_dm200_hrtimer/](/media/jason/btrfs_disk_M/Develop/allwinner/t536/V1.1/bsp/drivers/sanway/spi_adc_dm200_hrtimer/)

**设计有几点需要注意：**

- **不能采用中断方式读写：**

T536的GPIO中断经过测试，在选择下降沿中断时，其本身有一个分辨率，实测脉宽不能低于200us，否则就无法识别中断。而AD7616的`BUSY`管脚无法满足这个条件。因此只能改为采用`HRTIMER`方式读写。

- **采用HRTIMER后，也不能使用PWM0，而是要将其改为GPIO方式来操作。DTB修改如下：**

```c
pwm@2090010 {
	pinctrl-names = "active", "sleep";
	pinctrl-0 = <&pwm0_0_pins_active>;
	pinctrl-1 = <&pwm0_0_pins_sleep>;
	status = "disabled";
};

spi@4025000 {
	pinctrl-0 = <&spi0_pins_default &spi0_pins_cs>;
	pinctrl-1 = <&spi0_pins_sleep>;
	pinctrl-names = "default", "sleep";
	sunxi,spi-bus-mode = <SUNXI_SPI_BUS_MASTER>;	/*SUNXI_SPI_BUS_MASTER*/
	sunxi,spi-cs-mode = <SUNXI_SPI_CS_SOFT>;	/*SUNXI_SPI_CS_AUTO*/
	// spi-cpol;
    // spi-cpha;
    
	spiadc@0 {
		compatible = "sanway,spiadc";
		reg = <0>;
		spi-max-frequency = <50000000>;
		spi-rx-bus-width = <1>;
		spi-tx-bus-width = <1>;
		interrupt-parent = <&pio>;
		interrupts = <PC 7 IRQ_TYPE_EDGE_FALLING>;
		reset-gpios = <&pio PH 8 GPIO_ACTIVE_LOW>;
		convst-gpios = <&pio PD 23 GPIO_ACTIVE_HIGH>;
		status = "okay";
	};
};
```

这里将`PD23`作为了GPIO使用，并且会在HRTIMER中直接驱动：

```c
static inline void adc_sample_once(struct cpld_spi_cmd_priv *drvdata, int us_delay)
{
	gpiod_set_value(drvdata->gpiod_convst, 1);
	udelay(us_delay);
	gpiod_set_value(drvdata->gpiod_convst, 0);
}
```

- **HRTIMER的回调函数中不能调用SPI的读写函数：**

这是因为在HRTIMER的回调函数中不能有任何的阻塞、睡眠或者调度的情况。因此需要增加work队列：

```c
struct work_struct			spi_work;
```

然后在HRTIMER回调函数中去调度工作队列，在工作队列中去进行SPI读写操作。

并且，为了提高CPU的运行效率，我还将工作队列回调函数绑定到了CPU1上运行：

```c
//初始化工作队列
INIT_WORK(&priv->spi_work, spi_adc_work_func);
priv->target_cpu = 1; // 例如绑定到CPU1，可根据实际情况设置
priv->wq = alloc_workqueue("spi_adc_wq", WQ_UNBOUND | WQ_HIGHPRI, 1);
if (!priv->wq) {
	dev_err(dev, "Failed to alloc workqueue\n");
    	goto cdev_err3;
}

...
    
//HRTIMER回调函数中运行
queue_work_on(drvdata->target_cpu, drvdata->wq, &drvdata->spi_work);
```

- **设计循环缓冲区，将SPI的spi_rx_buf直接内存映射：**

为了提高内存映射和使用效率，SPI的接收缓存可以这样设计：

```c
priv->mmap_start = devm_kzalloc(dev, RECORD_BUF_SIZE_MAX, GFP_KERNEL);
if (priv->mmap_start == NULL) {
	dev_err(dev, "mem_start kmalloc failed\n");
	return -ENOMEM;
} 
dev_info(dev, "kmalloc address start: 0x%p, memsize: %d(KB)\n", 
		priv->mmap_start, (RECORD_BUF_SIZE_MAX/ 1000));
priv->spi_rx_buf = (u8 *)priv->mmap_start;
```

即将spi_rx_buf的指针直接指向mmap_start，然后内存映射mmap_start：

```c
static int esam_mmap(struct file *filep, struct vm_area_struct *vma)                                               
{                                                                                                                  
        unsigned long page;                                                                                        
        struct cpld_spi_cmd_priv *drvdata = filep->private_data;                                                                  
                                                                                                                   
        page = virt_to_phys(drvdata->mmap_start);                                                                        
        if(remap_pfn_range(vma, vma->vm_start, page >> PAGE_SHIFT, vma->vm_end - vma->vm_start, vma->vm_page_prot))
                return -EAGAIN;                                                                                    
                                                                                                                   
        return 0;                                                                                                  
}                                                                                                    
```

映射完成后，这段内存将作为循环缓冲区使用。使用方法：

```c
u8 *buf = &drvdata->spi_rx_buf[drvdata->offset];
//读取ADC数据
ret = spi_read(spi, buf, SPI_BYTE_MAX_LEN);
if(ret < 0) {
	dev_err(dev, "spi_read failed: ret = %d\n", ret);
	return;
}
//计算缓存区的位置和每次新的数据长度
drvdata->offset += SPI_BYTE_MAX_LEN;
drvdata->offset %= RECORD_BUF_SIZE_MAX;
```

这样就实现了SPI接收的循环缓冲模式。

##### 2）测试程序：

程序路径：[/media/jason/btrfs_disk_M/Develop/allwinner/sanway/珠海万力达_20250716/李山德项目_20250820/dm-200[CPU-T5]-2508-V3.00/test_adc/](/media/jason/btrfs_disk_M/Develop/allwinner/sanway/珠海万力达_20250716/李山德项目_20250820/dm-200[CPU-T5]-2508-V3.00/test_adc/)

运行时需要将其绑定到CPU2或者CPU3上：

```sh
taskset -c 3 ./update_files/test/test_adc_hrtimer 500 1
```

上面的命令就是将测试程序绑定到CPU3上运行。

> - 参数1：表示采样间隔，单位us。最小可设置为：78，表示一个周波采样256点。
> - 参数2：是否打印采样结果。1为打印，0为不打印。

因为我在测试程序中做了一个死循环，因此运行后，通过`htop`查看CPU资源占用情况：

![](/media/sf_D_DRIVE/BaiduNetdiskWorkspace/VNote笔记本_20200401/我的笔记本/全志T536开发相关/珠海万力达/屏幕截图 2025-08-29 082853.png)

可以看到CPU3的占用率为100%。

程序运行后的打印输出：

```sh
####MMAP memory success: 0x0x7f8b817000
adc sample cycle: 500
0x284e 0x283a 0x2897 0x280c 0x2833 0x28c4 0x286b 0x1f72 0x284e 0x2839 0x2897 0x280d 0x2832 0x28c4 0x286b 0x1f6f 
0x284c 0x2838 0x2894 0x280a 0x2830 0x28c0 0x2869 0x1f70 0x2849 0x2836 0x2893 0x2808 0x282f 0x28bf 0x2867 0x1f72 
0x284b 0x2837 0x2892 0x2808 0x2830 0x28bf 0x2867 0x1f71 0x2849 0x2837 0x2893 0x2808 0x2830 0x28bf 0x2868 0x1f73 
0x2849 0x2837 0x2892 0x2808 0x2830 0x28bf 0x2868 0x1f71 0x2843 0x2832 0x288a 0x2803 0x282c 0x28b4 0x2863 0x1f64 
...
```

我这里根据采样的值进行了计算，按照AD7616数据手册中的计算公式：

```sh
CODE = (VIN / 5V) x 32768 x (2.5 / REFINOUT)
```

得出

```sh
VIN = (CODE x 5) / 32768
```

例如：0x1f72，转为十进制为：8050，则采样值计算公式为：

```sh
8050 x 5 / 32768 = 1.228V
```

根据图纸设计，这一路接的是`AD_CH15`（还有`AD_CH0`和其并联）：

![image-20250829080436013](/media/sf_D_DRIVE/BaiduNetdiskWorkspace/VNote笔记本_20200401/我的笔记本/全志T536开发相关/珠海万力达/image-20250829080436013.png)

根据上面的图，AD_CH5的电压应该为：

```sh
(3.3K / (10K + 3.3K)) x 5V = 1.24V
```

证明采样值和理论的计算值是一致的。

#### 3.5. GPIO LBUS总线设计：

> - 对于CS、ALE、RD、WR这几路信号，可以采用GPIO方式来分别模拟时序；
> - 对于地址数据总线，则需要通过读写GPIO的寄存器，来一次性操作。因为Linux内核的GPIO操作函数一次只能操作一路GPIO，效率太低。

按照用户手册中的描述（见手册第`1387`页），PA~PK每个BANK寄存器的定义，我们可以这样来设计：

（以PK组为例，因为设计上PK0~PK15作为了地址数据线）：

```c
#define PK_REG_WIDTH	4
enum GPIO_PK_REGS {
    REG_CFG0 = 0x00,
    REG_CFG1 = 0x04,
    REG_CFG2 = 0x08,
    REG_CFG3 = 0x0C,
    REG_DAT  = 0x10,
    REG_DAT_SET = 0x14,
    REG_DAT_CLR = 0x18,
    REG_DRV0 = 0x20,
    REG_DRV1 = 0x24,
    REG_DRV2 = 0x28,
    REG_DRV3 = 0x2C,
    REG_PUL0 = 0x30,
    REG_PUL1 = 0x34,
    REG_INT_CFG0 = 0x40,
    REG_INT_CFG1 = 0x44,
    REG_INT_CFG2 = 0x48,
    REG_INT_CFG3 = 0x4C,
    REG_INT_CTL = 0x50,
    REG_INT_STA = 0x54,
    REG_INT_DEB = 0x58
};
```

