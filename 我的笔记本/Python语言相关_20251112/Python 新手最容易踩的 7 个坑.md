# Python 新手最容易踩的7个坑

很多刚学 Python 的人，总觉得学会 print、会写 if/for、能跑通一个小 demo，就算“入门”了。但真正开始写项目时，才会发现 Python 的坑比你想象的深得多。更关键的是，这些坑不是复杂知识，而是那些你以为“会了”，实际上却“没弄明白”的基础。


我见过的 Python 新手，90% 都会在差不多的地方摔跟头——变量作用域不理解、可变对象乱改、列表复制踩雷、默认参数自爆、编码问题莫名出现……最可怕的是，你可能一直以为是 Python 的问题，而其实是你的理解方式导致你掉入陷阱。

今天我想把这篇文章写得足够“有用”，不耍花活、不堆概念，把新手最常见的 7 个坑拆开，从“为什么会踩坑”到“高手怎么处理”讲得清清楚楚。写代码真的没有捷径，但思维方式可以让你少走很多弯路。

---

很多人不知道，Python 的变量不是你以为的那种“盒子”。你写了 a = 10，你以为是把 10 放进了 a，实际上 a 只是指向 10 这个对象的一个标签。看似没差，但这里埋着 Python 新手的第一个大坑：修改对象的时候，改的可不是“变量”，而是“对象本身”。

比如这段代码，新手几乎都会写出 bug：

```python
nums = [1, 2, 3]
new_nums = nums
new_nums.append(4)
print(nums)
```

你以为 new_nums 是副本，结果你只是复制了一个引用。输出变成 [1,2,3,4]，你可能还以为 Python 出 bug 了。

高手不会这样写，他们要么明确复制：

```python
new_nums = nums.copy()
```

要么明确标记“我就是要共享同一个对象”。 这不是技巧，而是一种态度：知道自己在操作什么，不让代码靠运气运行。

---

第二个坑比第一个更隐蔽——函数默认参数。如果你在某个群里问：“为什么函数默认参数会一直累积？”一定会有人回你一句：“因为 Python 的默认参数在定义时就被计算了。”

但问题是，99% 的新手并不真正理解“定义时就被计算”是什么意思。

最典型的例子：

```python
def add_item(item, lst=[]):
    lst.append(item)
    return lst

print(add_item(1))
print(add_item(2))
```

你以为会输出 [1] 和 [2]，结果是：

```sh
[1]
[1, 2]
```

因为 lst=[] 只初始化一次，而不是每次调用都生成新列表。

高手根本不会给可变对象做默认值，他们会这样写：

```python
def add_item(item, lst=None):
    lst = lst or []
    lst.append(item)
    return lst
```

这就是经验，也是教训换来的规律：任何涉及“可变对象”的问题，一定要提前警觉。

---

第三个坑和“作用域”相关，几乎每一个 Python 新手在某个深夜都被它折磨过。你可能写过类似的代码：

```python
count = 10

def add():
    count += 1
    return count
```

结果直接报错：UnboundLocalError。你明明没有定义局部变量，为什么 Python 偏要说你用了？

因为 Python 看到 count +=1 就自动认为 count 是局部变量，而不会去外层找。

很多新手崩溃在这里，而高手只是轻轻写一句：

```python
global count
```

或者更专业的闭包写法：

```python
def counter():
    count = 10
    def add():
        nonlocal count
        count += 1
        return count
    return add
```

区别在哪？新手的关注点是“为什么不行”，高手的关注点是“Python 规则是什么，我应该怎么用它”。

---

第四个坑是 Python 的“可变参数”。当你第一次看到 *args 和 **kwargs 时，你可能会觉得新鲜，但写多了你就会发现，它们是双刃剑。

一个典型新手错误是：

```python
def func(*args):
    print(args[0])
```

别人传了 0 个参数，你的程序瞬间报错。

高手写代码不会“假设别人会正确使用”，他们会：

```python
def func(*args):
    if not args:
        return None
    return args[0]
```

或者写得更健壮：

把“安全性”融入到习惯，而不是等出问题后再补丁。

---

第五个坑往往出现在刚开始接触文件、API 或数据库的时候。你可能写过类似的代码：

```python
f = open("data.txt")
data = f.read()
```

你以为这样没问题，但真实情况是你根本没有关闭文件。 文件描述符泄漏在小脚本里不明显，但在服务端会让你当场下跪。

高手不会这样写，他们永远用 with：

```python
with open("data.txt") as f:
    data = f.read()
```

这句语句背后，藏着“上下文管理器”这种 Python 的高级语法糖。你不需要知道底层实现，但要知道：with 才是打开文件的唯一正确姿势。

---

第六个坑来自“复制列表”。很多人以为 list2 = list1.copy() 就是完全复制，但他们不知道 copy() 是浅拷贝。

比如：

```python
a = [[1],[2],[3]]
b = a.copy()
b[0].append(99)
print(a)
```

输出是：

```sh
[[1, 99], [2], [3]]
```

你以为你复制了一份，结果你只是复制了一层。

高手不仅知道浅拷贝 vs 深拷贝的区别，还知道什么时候应该用：

```python
import copy
copy.deepcopy(a)
```

最关键的是，他们知道哪些对象适合拷贝、哪些对象共享更合理。

真正的差距不是知识多少，而是“何时用、为何用”的清醒感。

---

最后一个坑，是几乎所有新手都会忽略的：编码错误。比如你读一个文件：

```python
open("xxx.txt").read()
```

结果报错：UnicodeDecodeError。

你可能会在群里问：“为什么 Python 读文件这么难用？” 但高手不会问这个问题，他们会写：

```python
open("xxx.txt", encoding="utf-8")
```

或者在不确定编码时：

```python
open("xxx.txt", errors="ignore")
```

> [!note]
>
> 因为高手知道：**不是 Python 提前你，而是你没有提前设计好边界。**

---

写到这里，你应该能感受到一个事实：Python 的坑不是 Python 的问题，而是你在写代码时的思维方式决定的。

新手关注“怎么写能跑”，老手关注“怎么写可维护、可扩展、不容易出错”。 新手把问题当作偶然，高手把问题当作必然。 同样是写代码，新手修 bug，高手修逻辑。

我见过最厉害的工程师，他们从来不会嘲笑新手的错误，因为他们自己曾经也摔在同样的坑里。区别只是，他们后来选择了把问题挖深、理解透，而不是在表层修补。

如果你现在正在学 Python，也正在为这些坑烦恼，请放心：每一个程序员都走过这条路。 你不是笨，也不是学不好，只是你刚上路，而这些坑本来就摆在那里。关键不在于你摔了多少次，而是你愿不愿意站起来，把坑踩成经验。

真正的成长不是写出第一行 Hello World，而是你开始能像专业工程师一样去思考代码。 如果你读到了这里，那么你已经迈出了这一步。