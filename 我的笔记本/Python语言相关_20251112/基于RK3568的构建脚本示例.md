# 基于RK3568的构建logo的Python代码示例

之前用脚本写了一个方便设置RK3568内核logo的构建脚本，现在也改写为了Python代码。代码如下：

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import sys
import configparser

#操作菜单选项名称
build_debug = False

build_items = (
    "exit              ",
    "default           ",
    "wanlida           ",
    "kechuang_800x600  ",
    "kechuang_1024x600 ",
    "Set INI DTB       ",
    "Set kernel DTB    ",
    "build kernel image"
)

#操作菜单选项说明
build_items_explain = (
    "退出程序",
    "切换到Rockchip Kernel logo配置",
    "切换到Wanlida Kernel logo配置",
    "切换到Kechuang Kernel 800x600 logo配置",
    "切换到Kechuang Kernel 1024x600 logo配置",
    "设置config.ini配置文件中[DTB_FILE_NAME]的值",
    "用当前config.ini配置文件中的[DTB_FILE_NAME]值设置kernel DTB",
    "用以上配置来编译kernel内核映像",
)

#INI文件中的sections和options名称
sections_name = (
    "DIR_SET", 
    "PIC_SET", 
    "DTB_SET"
)

options_name = (
    "DIR_ROOT", 
    "LOGO_BMP", 
    "LOGO_KERNEL_BMP", 
    "LOGO_KERNEL_PPM", 
    "DIR_BOARD_CONFIG", 
    "DTB_FILE_NAME"
)

# ANSI escape sequences (use \033 for portability)
red='\033[1;31m'
RED='\033[1;31m'
blue='\033[0;34m'
BLUE='\033[1;34m'
cyan='\033[0;36m'
CYAN='\033[1;36m'
green='\033[0;32m'
GREEN='\033[1;32m'
yellow='\033[1;33m'
YELLOW='\033[1;33m'
PURPLE='\033[1;35m'
purple='\033[0;35m'
error='\033[1;41m'
warn='\033[1;43m'
nc='\033[0m'

class my_print:
    def __init__(self):
        # ANSI escape sequences (use \033 for portability)
        # red='\033[1;31m'
        # RED='\033[1;31m'
        # blue='\033[0;34m'
        # BLUE='\033[1;34m'
        # cyan='\033[0;36m'
        # CYAN='\033[1;36m'
        # green='\033[0;32m'
        # GREEN='\033[1;32m'
        # yellow='\033[1;33m'
        # YELLOW='\033[1;33m'
        # PURPLE='\033[1;35m'
        # purple='\033[0;35m'
        # error='\033[1;41m'
        # self.warn='\033[1;43m'
        # self.nc='\033[0m'
        pass
    
    def print_prefix_colored(self, prefix, message, color):
        print(f"{prefix}", end='', flush=True)
        print(f"{color}{message}{nc}")
        
    def print_suffix_colored(self, suffix, message, color):        
        print(f"{color}{message}{nc}", end='', flush=True)
        print(f"{suffix}")
        
    def print_colored(self, message, color):
        #print(f"{color}{message}{nc}")
        self.print_prefix_colored('', message, color)
        
    def check_file_exists(self, file_path, exit_flag = True):
        if os.path.isfile(file_path):
            self.print_suffix_colored(f'{file_path}', f'文件存在: ', GREEN)
            return True
        else:
            self.print_suffix_colored(f'{file_path}', f'文件不存在: ', RED)
            if exit_flag:
                sys.exit(1)
            else:
                return False
            
    def check_dir_exists(self, dir_path, exit_flag = True):
        if os.path.isdir(dir_path):
            self.print_suffix_colored(f'{dir_path}', f'目录存在: ', GREEN)
            return True
        else:
            self.print_suffix_colored(f'{dir_path}', f'目录不存在: ', RED)
            if exit_flag:
                sys.exit(1)
            else:
                return False
        
    def linux_cmd_run(self, cmd, exit_flag = True):
        self.print_colored(f'开始执行: {cmd}', YELLOW)
        ret = os.system(cmd)
        if ret != 0:
            self.print_colored(f'执行命令：{cmd} 失败', RED)
            if exit_flag:
                sys.exit(1)
            else:
                return False
        else:
            self.print_colored(f'执行命令：{cmd} 成功', GREEN)
            return True
        
# 全局实例化my_print类
color_print = my_print()
FILE_CONFIG = "config.ini"
dir_config = './config'
dir_root = ''
dir_kernel = dir_root + '/kernel'
dir_kernel_logo = dir_kernel + '/drivers/video/logo'
logo_bmp = ''
logo_kernel_bmp = ''
logo_kernel_ppm = ''
dir_board_config = ''
dtb_file_name = ''

class Conf:
    def __init__(self):
        self.conf = configparser.ConfigParser()
        self.root_path = os.path.dirname(os.path.abspath(__file__))
        self.f = os.path.join(self.root_path + '/' + FILE_CONFIG)
        self.conf.read(self.f)
        self.my_print = my_print()

    def read_sections(self):
        print(f"1、获取所有的sections:{self.conf.sections()}")

    def read_options(self, s1, s2):
        print(f"2、获取所有的options:{self.conf.options(s1)}")
        print(f"3、获取所有的options:{self.conf.options(s2)}")

    def read_conf(self, m, n):
        name = self.conf.get(m, n)  # 获取指定section的option值
        # print(f"4、获取指定section:{m}下的option：{n}的值为{name}")
        self.my_print.print_suffix_colored(f" = {name}", f"[{m}] -> [{n}]\t", YELLOW)
        return name 

    def get_items(self, m, n):
        print(f"获取sectoion:{m}下的配置信息为：{self.conf.items(m)}")
        print(f"获取sectoion:{n}下的配置信息为：{self.conf.items(n)}")

    def set_option(self, m, n, s):
        self.conf.set(m, n, s)
        self.conf.write(open(self.f, "w"))
        self.my_print.print_suffix_colored(f" = {s}", f"[{m}] -> [{n}]\t", GREEN)

    def has_s_o(self, s, o):
        print(f"8、检查section：{s}是否存在：{self.conf.has_section(s)}")
        print(f"9、检查section：{s}下的option：{o}是否存在：{self.conf.has_option(s, o)}")

    def add_s_o(self, s, o, v):
        if not self.conf.has_section(s):
            self.conf.add_section(s)
            print(f"10、添加新的section为{s}")
        else:
            print(f"10、添加新的section为{s}已经存在，无需添加！")
        if not self.conf.has_option(s, o):
            self.conf.set(s, o, v)
            print(f"11、要添加的option为{o}, 值为{v}")
        else:
            print(f"11、要添加的option为{o}, 值为{v}，已经存在，无需添加！")
        self.conf.write(open(self.f, "w"))

    def remove_s_o(self, s, o):
        if self.conf.has_section(s):
            self.conf.remove_section(s)
            print(f"12、删除section:{s}==OK!")
        else:
            print(f"12、要删除的section:{s}不存在，不用删除！")
        if self.conf.has_option(s, o):
            self.conf.remove_option(s, o)
            print(f"13、删除section：{s}下的option：{o}==OK!")
        else:
            print(f"13、要删除的section：{s}下的option：{o}不存在，不用删除！")
            
def ini_read_info():
    # ensure function updates module-level variables
    global dir_root, dir_kernel, dir_kernel_logo, logo_bmp, logo_kernel_bmp, logo_kernel_ppm, dir_board_config, dtb_file_name
    aa = Conf()
    
    print("\n==========================================================")
    print("当前的config.ini配置文件中的所有section和option如下：\n")
    
    for section in sections_name:
        match section:
            case "DIR_SET":
                option = options_name[0]
                dir_root = aa.read_conf(section, option)
                dir_kernel = dir_root + '/kernel'
                dir_kernel_logo = dir_kernel + '/drivers/video/logo'
            case "PIC_SET":
                for option in options_name[1:4]:
                    match option:
                        case "LOGO_BMP":
                            logo_bmp = aa.read_conf(section, option)
                        case "LOGO_KERNEL_BMP":
                            logo_kernel_bmp = aa.read_conf(section, option)
                        case "LOGO_KERNEL_PPM":
                            logo_kernel_ppm = aa.read_conf(section, option)
                        case _:
                            print(f"Unknown option: {option}")
            case "DTB_SET":
                for option in options_name[4:6]:
                    match option:
                        case "DIR_BOARD_CONFIG":
                            dir_board_config = aa.read_conf(section, option)
                        case "DTB_FILE_NAME":
                            dtb_file_name = aa.read_conf(section, option)
                        case _:
                            print(f"Unknown option: {option}")
            case _:
                print("No matching section found.")
                
    print("==========================================================\n")
    
    # 打印配置信息
    print("当前系统脚本相关的全局变量如下：\n")
    color_print.print_suffix_colored(f' = {dir_root}', f'dir_root \t', YELLOW)
    color_print.print_suffix_colored(f' = {dir_kernel}', f'dir_kernel \t', YELLOW)
    color_print.print_suffix_colored(f' = {dir_kernel_logo}', f'dir_kernel_logo ', YELLOW)
    color_print.print_suffix_colored(f' = {logo_bmp}', f'logo_bmp \t', YELLOW)
    color_print.print_suffix_colored(f' = {logo_kernel_bmp}', f'logo_kernel_bmp ', YELLOW)
    color_print.print_suffix_colored(f' = {logo_kernel_ppm}', f'logo_kernel_ppm ', YELLOW)
    color_print.print_suffix_colored(f' = {dir_board_config}', f'dir_board_config', YELLOW)
    color_print.print_suffix_colored(f' = {dtb_file_name}', f'dtb_file_name \t', YELLOW)
    
    print("==========================================================\n")
    
            

def print_menu():
    print("\n==========================================================")    
    color_print.print_prefix_colored(f'当前系统程序目录: \t', os.getcwd(), CYAN)
    color_print.print_prefix_colored(f'当前INI配置文件目录: \t', os.popen(f"ls -l {FILE_CONFIG}").read().strip().split(' ')[-1], CYAN)
    
    print("\n=========================系统菜单=========================")
    print("请选择要执行的操作:")
    #创建一个字典来存储项目和解释的对应关系
    dict1 = {build_items[i]: build_items_explain[i] for i in range(len(build_items))}
        
    if build_debug:
        #创建的这个字典，以build_items的值为KEY，以build_items_explain的值为VALUE
        print(dict1)
       
    # for key_index in build_items:
        # #打印行号，字典里的KEY，字典里的VALUE
        # item_no = build_items.index(key_index)
        # print(f"{item_no}. {key_index.lower()} - {dict1[key_index]}")
        
    #采用enumerate来简化上面的过程    
    # for item_no, value in enumerate(build_items):
        # print(f"{item_no}. {value.lower()} - {dict1[value]}")

    #采用另一种方式：字典的items()方法
    for item_no, (key, value) in enumerate(dict1.items()):
        print(f"{item_no}. {key.lower()}\t - {value}")
        
    print("\n==========================================================")
    choice = input("请输入你的选择: ").strip()
    return choice
    
def make_logo_bmp(file_sub_path):
    dir_tmp = dir_kernel_logo
    color_print.check_dir_exists(dir_tmp)
            
    file_tmp = dir_config + '/' + str(file_sub_path) + '/' + logo_bmp
    color_print.check_file_exists(file_tmp)
    color_print.linux_cmd_run(f"cp -raf {file_tmp} {dir_kernel}")
        
        
    file_tmp = dir_config + '/' + str(file_sub_path) + '/' + logo_kernel_bmp
    color_print.check_file_exists(file_tmp)
    color_print.linux_cmd_run(f"cp -raf {file_tmp} {dir_kernel}")
            
    try:
        os.chdir(dir_kernel)
    except Exception as e:
        color_print.print_colored(f'切换目录：{dir_kernel} 失败: {e}', RED)
        sys.exit(1)
    else:
        color_print.print_colored(f'切换目录：{dir_kernel} 成功', GREEN)
    
    color_print.linux_cmd_run(f"ln -sf {logo_bmp} logo.bmp")
    color_print.linux_cmd_run(f"ln -sf {logo_kernel_bmp} logo_kernel.bmp")
        
        
def make_kernel_logo_name(file_sub_path):
    file_tmp = dir_config + '/' + str(file_sub_path) + '/' + logo_kernel_ppm
    color_print.check_file_exists(file_tmp)
        
    dir_tmp = dir_kernel_logo
    color_print.check_dir_exists(dir_tmp)
        
    file_kernel_logo_tmp = "logo_linux_clut224.ppm"
    color_print.linux_cmd_run(f"cp -raf {file_tmp} {dir_kernel_logo}/{file_kernel_logo_tmp}")    
    color_print.linux_cmd_run(f"touch {dir_kernel_logo}/{file_kernel_logo_tmp}")
    

def build_kernel_logo(file_sub_path):
    file_config_tmp = dir_config + '/' + str(file_sub_path) + '/' + FILE_CONFIG
    color_print.check_file_exists(file_config_tmp)
    color_print.linux_cmd_run(f"ln -sf {file_config_tmp} {FILE_CONFIG}")
        
    # 链接完成后，重新读取配置文件中的信息
    ini_read_info()
    
    #对上面的全局变量进行操作
    dir_current = os.getcwd()
    make_logo_bmp(file_sub_path)
    
    try:
        os.chdir(dir_current)
    except Exception as e:
        color_print.print_colored(f'切换目录：{dir_current} 失败: {e}', RED)
        sys.exit(1)
    else:
        color_print.print_colored(f'切换目录：{dir_current} 成功', GREEN)
        
    make_kernel_logo_name(file_sub_path)
    
def build_command(build_param):
    build_sh = dir_root + '/build.sh'
    color_print.check_file_exists(build_sh)
    color_print.linux_cmd_run(f"{build_sh} {build_param}")
    
def set_ini_dtb_file_name():
    dir_kernel_dts = dir_kernel + '/arch/arm64/boot/dts/rockchip'
    
    input_dtb_file_name = input("请输入DTB文件名, 不需要带后缀（例如：rk3568-sanway-sw3568）: ")
    if not input_dtb_file_name.strip():
        color_print.print_colored(f'输入的DTB文件名不能为空', RED)
        return
    
    color_print.print_colored(f'输入的DTB文件名: {input_dtb_file_name}', YELLOW)
    
    # 检查输入的DTB文件名是否存在
    file_dtb = f"{dir_kernel_dts}/{input_dtb_file_name}.dts"
    
    #如果文件不存在，则不退出程序，返回False
    if not color_print.check_file_exists(file_dtb, exit_flag=False):
        return
    
    if input_dtb_file_name.strip() == dtb_file_name.strip():
        color_print.print_colored(f'输入的DTB文件名与当前config.ini配置文件中的DTB_FILE_NAME值相同，无需修改', GREEN)
        return
    
    # 修改config.ini配置文件中的DTB_FILE_NAME值
    aa.set_option("DTB_SET", "DTB_FILE_NAME", input_dtb_file_name)
    
    # 打印提示信息
    color_print.print_colored(f'config.ini配置文件中的DTB_FILE_NAME值已修改为: {input_dtb_file_name}', GREEN)
    
    # 重新读取配置文件中的信息
    ini_read_info()
    
def set_kernel_dtb_file_name():
    dir_kernel_dts = dir_kernel + '/arch/arm64/boot/dts/rockchip'
    board_config_dtb_file = 'BoardConfig-sanway-rk3568-evb1-ddr4-v10-32bit.mk'
    board_config_dtb_section = 'RK_KERNEL_DTS'
    
    print(f"INI set DTB dir: {dir_board_config}")
    if not color_print.check_dir_exists(dir_board_config, exit_flag=False):
        return
    
    print(f"INI set DTB file: {dtb_file_name}")
    if not color_print.check_file_exists(f"{dir_kernel_dts}/{dtb_file_name}.dts", exit_flag=False):
        return
    
    board_config_dtb_file_name = os.popen(f"cat {dir_board_config}/{board_config_dtb_file} | grep {board_config_dtb_section} | grep -v '^#'").read().strip().split('=')[-1].strip()
    if not board_config_dtb_file_name:
        color_print.print_colored(f'无法从{dir_board_config}/{board_config_dtb_file}文件中获取当前kernel DTB文件名', RED)
        return
    
    color_print.print_prefix_colored(f'当前kernel DTB文件名为: ', board_config_dtb_file_name, GREEN)
    
    if board_config_dtb_file_name == f"{dtb_file_name}":
        color_print.print_colored(f'kernel DTB文件名与当前config.ini配置文件中的DTB_FILE_NAME值相同，无需修改', GREEN)
        return
    
    # 修改kernel DTB文件名
    color_print.print_prefix_colored(f'修改kernel DTB文件名为: ', dtb_file_name, YELLOW)
    color_print.linux_cmd_run(f"sed -i 's/{board_config_dtb_file_name}/{dtb_file_name}/g' {dir_board_config}/{board_config_dtb_file}")
    
def build_item(item):
    build_cmd_full = f"{build_items[item].strip()}"
    print(f"Building item: {build_cmd_full}")
    
    if build_items[item].strip() == "exit":
        color_print.print_colored("退出成功", GREEN)
        sys.exit(0)
        
    # if build_items[item].strip() == "default":
        # print("切换到Rockchip Kernel logo配置: " + "default")
        # build_kernel_logo("default")
        
    # 计算菜单中“logo 配置项”和“其他操作项”的分界点。
    # 以前使用 .index(',') 会抛出异常（因为条目里没有逗号），改为查找第一个以 'Set' 或 'build' 开头的项。
    item_no = None
    for i, bi in enumerate(build_items):
        s = bi.strip()
        if s.lower().startswith('set') or s.lower().startswith('build'):
            item_no = i
            break
    if item_no is None:
        # 如果没找到，退化为整个列表长度（没有特殊操作项）
        item_no = len(build_items)
        color_print.print_colored("未找到特殊操作项!", RED)
        sys.exit(1)
        
    if build_debug:
        print(f"item_no: {item_no}")
        
    if item < item_no:
        build_param = build_items[item].strip()
        print("\n==========================================================")
        print(f"切换到Rockchip Kernel logo配置: {build_param}")
        build_kernel_logo(build_param)
        print("==========================================================\n")
        
    if item >= item_no and item < len(build_items):
        color_print.print_colored(f'执行操作: {build_items[item].strip()}', GREEN)
        match build_items[item].strip():
            case "Set INI DTB":
                set_ini_dtb_file_name()
            case "Set kernel DTB":
                set_kernel_dtb_file_name()
            case "build kernel image":
                build_command("kernel")
            case _:
                color_print.print_colored(f'操作 {build_items[item].strip()} 尚未实现!', RED)
                sys.exit(1)
        
            
if __name__ == "__main__":
    # color_print = my_print()
    aa = Conf()
    # aa.read_sections()
    # aa.read_options("PIC_SET", "DTB_SET")
    # aa.read_conf("PIC_SET", "LOGO_BMP")
    # aa.read_conf("PIC_SET", "LOGO_KERNEL_BMP")
    # aa.get_items("PIC_SET", "DTB_SET")
    # aa.set_option("mysqldb", "sql_name", "游客")
    # aa.has_s_o("mysqldb", "sql_name")
    # aa.add_s_o("login", "name", "root")
    # aa.remove_s_o("login", "name")
    ini_read_info()
                
    color_print.print_colored("\n本程序用于设置SW3568 Linux kernel启动显示logo ...", CYAN)
    
    while True:
        try:
            choice = print_menu()
            if choice == '':
                raise Exception
            if not choice.isdigit():
                raise TypeError
            if int(choice) < 0 or int(choice) >= len(build_items):
                raise ValueError
            
        except TypeError:
            color_print.print_colored("输入的选择不是数字，请重新输入：", RED)
            continue
        except ValueError:
            color_print.print_colored("输入的选择超出范围，请重新输入：", RED)
            continue
        except Exception:
            color_print.print_colored("无效的选择，请重新输入：", RED)
            continue
        else:
            color_print.print_prefix_colored("你选择的项目: ", f"[{choice}. {build_items[int(choice)].strip()}]", CYAN)
            build_item(int(choice.strip()))

```

